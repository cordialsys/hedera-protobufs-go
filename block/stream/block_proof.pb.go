//*
// # Block Proof
// A proof for the block streamed from a consensus node.
//
// ### Keywords
// The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
// "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
// document are to be interpreted as described in
// [RFC2119](https://www.ietf.org/rfc/rfc2119) and clarified in
// [RFC8174](https://www.ietf.org/rfc/rfc8174).

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v5.29.3
// source: stream/block_proof.proto

package stream

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// *
// A cryptographic proof for the "Block Merkle Tree".
//
// This message SHALL offer a proof for the "Block Merkle Tree".
// The information in the "Block Merkle Tree" SHALL be used to validate the
// full content of the most recent block, and, with chained validation,
// all prior blocks.
//
// ### Block Merkle Tree
// The Block Hash of any block is a merkle root hash comprised of a 4 leaf
// binary merkle tree. The 4 leaves represent
// 1. Previous block proof hash
// 1. Merkle root of transaction inputs tree
// 1. Merkle root of transaction outputs tree
// 1. Merkle rook of state tree
//
// #### Computing the hash
// The process for computing a block hash is somewhat complex, and involves
// creating a "virtual" merkle tree to obtain the root merkle hash of
// that virtual tree.<br/>
// The merkle tree SHALL have a 4 part structure with 2 internal nodes,
// structured in a strictly binary tree.
//   - The merkle tree root SHALL be the parent of both
//     internal nodes.
//     1. The first "internal" node SHALL be the parent of the
//     two "left-most" nodes.
//     1. The first leaf MUST be the previous block hash, and is a
//     single 48-byte value.
//     1. The second leaf MUST be the root of a, strictly binary, merkle tree
//     composed of all "input" block items in the block.<br/>
//     Input items SHALL be transactions, system transactions,
//     and events.<br/>
//     Leaf nodes in this subtree SHALL be ordered in the same order
//     that the block items are encountered in the stream.
//     1. The second "internal" node SHALL be the parent of the two
//     "right-most" nodes.
//     1. The third leaf MUST be the root of a, strictly binary, merkle tree
//     composed of all "output" block items in the block.<br/>
//     Output items SHALL be transaction result, transaction
//     output, and state changes.<br/>
//     Leaf nodes in this subtree SHALL be ordered in the same order that
//     the block items are encountered in the stream.
//     1. The fourth leaf MUST be the merkle tree root hash for network state
//     at the start of the block, and is a single 48-byte value.
//   - The block hash SHALL be the hash calculated for the root of this merkle
//     tree.
//   - The hash algorithm used SHALL be the algorithm specified in the
//     corresponding block header.
//
// The "inputs" and "outputs" subtrees SHALL be "complete" binary merkle trees,
// with nodes that would otherwise be missing replaced by a "null" hash
// leaf.
type BlockProof struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// The block this proof secures.<br/>
	// We provide this because a proof for a future block can be used to prove
	// the state of the ledger at that block and the blocks before it.<br/>
	// <p>
	// This value SHOULD match the block number of the current block,
	// under normal operation.
	Block uint64 `protobuf:"varint,1,opt,name=block,proto3" json:"block,omitempty"`
	// *
	// A merkle root hash of the previous block.
	// <p>
	// This MUST contain a hash of the "block" merkle tree root for the
	// previous block.<br/>
	// The hash algorithm used MUST match the algorithm declared in the
	// block header _for that block_.
	PreviousBlockRootHash []byte `protobuf:"bytes,2,opt,name=previous_block_root_hash,json=previousBlockRootHash,proto3" json:"previous_block_root_hash,omitempty"`
	// *
	// A merkle root hash of the network state.<br/>
	// This is present to support validation of this block proof by clients
	// that do not maintain a full copy of the network state.
	// <p>
	// This MUST contain a hash of the "state" merkle tree root at the start
	// of the current block (which this block proof verifies).<br/>
	// State processing clients SHOULD calculate the state root hash
	// independently and SHOULD NOT rely on this value.<br/>
	// State processing clients MUST validate the application of state changes
	// for a block using the value present in the Block Proof of the
	// _following_ block.
	// Compliant consensus nodes MUST produce an "empty" block (containing
	// only `BlockHeader` and `BlockProof` as the last block prior to a
	// network "freeze" to ensure the final state hash is incorporated into
	// the Block Stream correctly.
	// Stateless (non-state-processing) clients MUST use this value to
	// construct the block merkle tree.
	StartOfBlockStateRootHash []byte `protobuf:"bytes,3,opt,name=start_of_block_state_root_hash,json=startOfBlockStateRootHash,proto3" json:"start_of_block_state_root_hash,omitempty"`
	// *
	// A TSS signature for one block.<br/>
	// This is a single signature representing the collection of partial
	// signatures from nodes holding strictly greater than 2/3 of the
	// current network "weight" in aggregate. The signature is produced by
	// cryptographic "aggregation" of the partial signatures to produce a
	// single signature that can be verified with the network public key,
	// but could not be produced by fewer nodes than required to meet the
	// threshold for network stake "weight".
	// <p>
	// This message MUST make use of a threshold signature scheme like `BLS`
	// which provides the necessary cryptographic guarantees.<br/>
	// This signature SHALL use a TSS signature to provide a single signature
	// that represents the consensus signature of consensus nodes.<br/>
	// The exact subset of nodes that signed SHALL neither be known nor
	// tracked, but it SHALL be cryptographically verifiable that the
	// threshold was met if the signature itself can be validated with
	// the network public key (a.k.a `LedgerID`).
	BlockSignature []byte `protobuf:"bytes,4,opt,name=block_signature,json=blockSignature,proto3" json:"block_signature,omitempty"`
	// *
	// A set of hash values along with ordering information.<br/>
	// This list of hash values form the set of sibling hash values needed to
	// correctly reconstruct the parent hash, and all hash values "above" that
	// hash in the merkle tree.
	// <p>
	// A Block proof can be constructed by combining the sibling hashes for
	// a previous block hash and sibling hashes for each entry "above" that
	// node in the merkle tree of a block proof that incorporates that previous
	// block hash. This form of block proof may be used to prove a chain of
	// blocks when one or more older blocks is missing the original block
	// proof that signed the block's merkle root directly.
	// <p>
	// This list MUST be ordered from the sibling of the node that contains
	// this block's root node hash, and continues up the merkle tree to the
	// root hash of the signed block proof.
	// <p>
	// If this block proof has a "direct" signature, then this list MUST be
	// empty.<br/>
	// If this list is not empty, then this block proof MUST be verified by
	// first constructing the "block" merkle tree and computing the root hash
	// of that tree, then combining that hash with the values in this list,
	// paying attention to the first/second sibling ordering, until the root
	// merkle hash is produced from the last pair of sibling hashes. That
	// "secondary" root hash MUST then be verified using
	// the value of `block_signature`.
	SiblingHashes []*MerkleSiblingHash `protobuf:"bytes,5,rep,name=sibling_hashes,json=siblingHashes,proto3" json:"sibling_hashes,omitempty"`
	// Types that are valid to be assigned to VerificationReference:
	//
	//	*BlockProof_SchemeId
	//	*BlockProof_VerificationKey
	VerificationReference isBlockProof_VerificationReference `protobuf_oneof:"verification_reference"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *BlockProof) Reset() {
	*x = BlockProof{}
	mi := &file_stream_block_proof_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BlockProof) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BlockProof) ProtoMessage() {}

func (x *BlockProof) ProtoReflect() protoreflect.Message {
	mi := &file_stream_block_proof_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BlockProof.ProtoReflect.Descriptor instead.
func (*BlockProof) Descriptor() ([]byte, []int) {
	return file_stream_block_proof_proto_rawDescGZIP(), []int{0}
}

func (x *BlockProof) GetBlock() uint64 {
	if x != nil {
		return x.Block
	}
	return 0
}

func (x *BlockProof) GetPreviousBlockRootHash() []byte {
	if x != nil {
		return x.PreviousBlockRootHash
	}
	return nil
}

func (x *BlockProof) GetStartOfBlockStateRootHash() []byte {
	if x != nil {
		return x.StartOfBlockStateRootHash
	}
	return nil
}

func (x *BlockProof) GetBlockSignature() []byte {
	if x != nil {
		return x.BlockSignature
	}
	return nil
}

func (x *BlockProof) GetSiblingHashes() []*MerkleSiblingHash {
	if x != nil {
		return x.SiblingHashes
	}
	return nil
}

func (x *BlockProof) GetVerificationReference() isBlockProof_VerificationReference {
	if x != nil {
		return x.VerificationReference
	}
	return nil
}

func (x *BlockProof) GetSchemeId() uint64 {
	if x != nil {
		if x, ok := x.VerificationReference.(*BlockProof_SchemeId); ok {
			return x.SchemeId
		}
	}
	return 0
}

func (x *BlockProof) GetVerificationKey() []byte {
	if x != nil {
		if x, ok := x.VerificationReference.(*BlockProof_VerificationKey); ok {
			return x.VerificationKey
		}
	}
	return nil
}

type isBlockProof_VerificationReference interface {
	isBlockProof_VerificationReference()
}

type BlockProof_SchemeId struct {
	// *
	// The id of the hinTS scheme this signature verifies under.
	SchemeId uint64 `protobuf:"varint,6,opt,name=scheme_id,json=schemeId,proto3,oneof"`
}

type BlockProof_VerificationKey struct {
	// *
	// The explicit hinTS key this signature verifies under; useful when
	// the verifier can easily check whether a chain-of-trust proof
	// exists for a key, but does does not have any context of the
	// latest hinTS schemes published in the block stream.
	VerificationKey []byte `protobuf:"bytes,7,opt,name=verification_key,json=verificationKey,proto3,oneof"`
}

func (*BlockProof_SchemeId) isBlockProof_VerificationReference() {}

func (*BlockProof_VerificationKey) isBlockProof_VerificationReference() {}

// *
// A hash of a "sibling" to an entry in a Merkle tree.
//
// When constructing a binary merkle tree, each internal node is a hash
// constructed from the hash of two "descendant" nodes. Those two nodes
// are "siblings" and the order (first, second) in which the two hash values
// are combined affects the parent hash.<br/>
// This may be used to reconstruct a portion of a merkle tree starting from
// a node of interest up to the root of the tree.
type MerkleSiblingHash struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// A flag for the position of this sibling.
	// <p>
	// If this is set then this sibling MUST be the first hash in the pair of
	// sibling hashes of a binary merkle tree.<br/>
	// If this is unset, then this sibling MUST be the second hash in the pair
	// of sibling hashes of a binary merkle tree.
	IsFirst bool `protobuf:"varint,1,opt,name=is_first,json=isFirst,proto3" json:"is_first,omitempty"`
	// *
	// A byte array of a sibling hash.<br/>
	// This is the hash for the sibling at this point in the merkle tree.
	// <p>
	// The algorithm for this hash SHALL match the algorithm for the block that
	// contains this sibling.<br/>
	// This SHALL contain the raw (e.g.) 384 bits (48 bytes) of the hash value.
	SiblingHash   []byte `protobuf:"bytes,2,opt,name=sibling_hash,json=siblingHash,proto3" json:"sibling_hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MerkleSiblingHash) Reset() {
	*x = MerkleSiblingHash{}
	mi := &file_stream_block_proof_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MerkleSiblingHash) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MerkleSiblingHash) ProtoMessage() {}

func (x *MerkleSiblingHash) ProtoReflect() protoreflect.Message {
	mi := &file_stream_block_proof_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MerkleSiblingHash.ProtoReflect.Descriptor instead.
func (*MerkleSiblingHash) Descriptor() ([]byte, []int) {
	return file_stream_block_proof_proto_rawDescGZIP(), []int{1}
}

func (x *MerkleSiblingHash) GetIsFirst() bool {
	if x != nil {
		return x.IsFirst
	}
	return false
}

func (x *MerkleSiblingHash) GetSiblingHash() []byte {
	if x != nil {
		return x.SiblingHash
	}
	return nil
}

var File_stream_block_proof_proto protoreflect.FileDescriptor

const file_stream_block_proof_proto_rawDesc = "" +
	"\n" +
	"\x18stream/block_proof.proto\x12\x1ccom.hedera.hapi.block.stream\"\x85\x03\n" +
	"\n" +
	"BlockProof\x12\x14\n" +
	"\x05block\x18\x01 \x01(\x04R\x05block\x127\n" +
	"\x18previous_block_root_hash\x18\x02 \x01(\fR\x15previousBlockRootHash\x12A\n" +
	"\x1estart_of_block_state_root_hash\x18\x03 \x01(\fR\x19startOfBlockStateRootHash\x12'\n" +
	"\x0fblock_signature\x18\x04 \x01(\fR\x0eblockSignature\x12V\n" +
	"\x0esibling_hashes\x18\x05 \x03(\v2/.com.hedera.hapi.block.stream.MerkleSiblingHashR\rsiblingHashes\x12\x1d\n" +
	"\tscheme_id\x18\x06 \x01(\x04H\x00R\bschemeId\x12+\n" +
	"\x10verification_key\x18\a \x01(\fH\x00R\x0fverificationKeyB\x18\n" +
	"\x16verification_reference\"Q\n" +
	"\x11MerkleSiblingHash\x12\x19\n" +
	"\bis_first\x18\x01 \x01(\bR\aisFirst\x12!\n" +
	"\fsibling_hash\x18\x02 \x01(\fR\vsiblingHashB^\n" +
	"#com.hedera.hapi.block.stream.protocP\x01Z5github.com/hashgraph/hedera-protobufs-go/block/streamb\x06proto3"

var (
	file_stream_block_proof_proto_rawDescOnce sync.Once
	file_stream_block_proof_proto_rawDescData []byte
)

func file_stream_block_proof_proto_rawDescGZIP() []byte {
	file_stream_block_proof_proto_rawDescOnce.Do(func() {
		file_stream_block_proof_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_stream_block_proof_proto_rawDesc), len(file_stream_block_proof_proto_rawDesc)))
	})
	return file_stream_block_proof_proto_rawDescData
}

var file_stream_block_proof_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_stream_block_proof_proto_goTypes = []any{
	(*BlockProof)(nil),        // 0: com.hedera.hapi.block.stream.BlockProof
	(*MerkleSiblingHash)(nil), // 1: com.hedera.hapi.block.stream.MerkleSiblingHash
}
var file_stream_block_proof_proto_depIdxs = []int32{
	1, // 0: com.hedera.hapi.block.stream.BlockProof.sibling_hashes:type_name -> com.hedera.hapi.block.stream.MerkleSiblingHash
	1, // [1:1] is the sub-list for method output_type
	1, // [1:1] is the sub-list for method input_type
	1, // [1:1] is the sub-list for extension type_name
	1, // [1:1] is the sub-list for extension extendee
	0, // [0:1] is the sub-list for field type_name
}

func init() { file_stream_block_proof_proto_init() }
func file_stream_block_proof_proto_init() {
	if File_stream_block_proof_proto != nil {
		return
	}
	file_stream_block_proof_proto_msgTypes[0].OneofWrappers = []any{
		(*BlockProof_SchemeId)(nil),
		(*BlockProof_VerificationKey)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_stream_block_proof_proto_rawDesc), len(file_stream_block_proof_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_stream_block_proof_proto_goTypes,
		DependencyIndexes: file_stream_block_proof_proto_depIdxs,
		MessageInfos:      file_stream_block_proof_proto_msgTypes,
	}.Build()
	File_stream_block_proof_proto = out.File
	file_stream_block_proof_proto_goTypes = nil
	file_stream_block_proof_proto_depIdxs = nil
}
