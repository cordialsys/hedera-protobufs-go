//*
// # Block Item
// A single item in the block stream, such as transaction data, event metadata,
// or a a system transaction.<br/>
// Each block consists of a block header, one or more block items,
// and a block state proof. Within the block are a series of events delimited
// by start_event block items.
//
// This structure here MUST support a stream of block items with no enclosing
// message.<br/>
// Implementations SHOULD behave in a reasonable manner if used in a gRPC
// bidirectional streaming RPC similar to
// `rpc processBlocks(stream BlockItem) returns (stream Acknowledgement);`.
//
// ### Keywords
// The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
// "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
// document are to be interpreted as described in
// [RFC2119](https://www.ietf.org/rfc/rfc2119) and clarified in
// [RFC8174](https://www.ietf.org/rfc/rfc8174).

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v5.29.3
// source: stream/block_item.proto

package stream

import (
	input "github.com/cordialsys/hedera-protobufs-go/block/stream/input"
	output "github.com/cordialsys/hedera-protobufs-go/block/stream/output"
	event "github.com/cordialsys/hedera-protobufs-go/platform/event"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// *
// A single item within a block stream.
//
// Each item in the block stream SHALL be self-contained and independent,
// with the following constraints applicable to the _unfiltered_ stream.
//   - A block SHALL start with a `header`.
//   - A block SHALL end with a `state_proof`.
//   - A `block_header` SHALL be followed by an `event_header`.
//   - An `event_header` SHALL be followed by one or more
//     `event_transaction` items.
//   - An `event_transaction` SHALL be followed by a `transaction_result`.
//   - A `transaction_result` MAY be followed by a `transaction_output`.
//   - A `transaction_result` (or a `transaction_output`, if present) MAY be
//     followed by one or more `state_changes`.
//
// This forms the following required sequence for each block, which is then
// repeated within the block stream, indefinitely.  Note that there is no
// container structure in the stream, the indentation below is only to
// highlight repeated subsequences.<br/>
// The order of items within each block below is REQUIRED and SHALL NOT change.
//
// ```text
// header
//
//	repeated {
//	  start_event
//	  repeated {
//	    event_transaction
//	    transaction_result
//	    (optional) transaction_output
//	    (optional) repeated state_changes
//	  }
//	}
//
// state_proof
// ```
// A filtered stream may exclude some items above, depending on filter
// criteria. A filtered item is replaced with a merkle path and hash value
// to maintain block stream verifiability.
//
// A BlockItem SHALL be individually and directly processed to create the
// item hash.<br/>
// Items to be hashed MUST NOT be contained within another item.<br/>
// Items which might be filtered out of the stream MUST NOT be
// contained in other items.
type BlockItem struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Item:
	//
	//	*BlockItem_BlockHeader
	//	*BlockItem_EventHeader
	//	*BlockItem_RoundHeader
	//	*BlockItem_EventTransaction
	//	*BlockItem_TransactionResult
	//	*BlockItem_TransactionOutput
	//	*BlockItem_StateChanges
	//	*BlockItem_FilteredItemHash
	//	*BlockItem_BlockProof
	//	*BlockItem_RecordFile
	Item          isBlockItem_Item `protobuf_oneof:"item"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BlockItem) Reset() {
	*x = BlockItem{}
	mi := &file_stream_block_item_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BlockItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BlockItem) ProtoMessage() {}

func (x *BlockItem) ProtoReflect() protoreflect.Message {
	mi := &file_stream_block_item_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BlockItem.ProtoReflect.Descriptor instead.
func (*BlockItem) Descriptor() ([]byte, []int) {
	return file_stream_block_item_proto_rawDescGZIP(), []int{0}
}

func (x *BlockItem) GetItem() isBlockItem_Item {
	if x != nil {
		return x.Item
	}
	return nil
}

func (x *BlockItem) GetBlockHeader() *output.BlockHeader {
	if x != nil {
		if x, ok := x.Item.(*BlockItem_BlockHeader); ok {
			return x.BlockHeader
		}
	}
	return nil
}

func (x *BlockItem) GetEventHeader() *input.EventHeader {
	if x != nil {
		if x, ok := x.Item.(*BlockItem_EventHeader); ok {
			return x.EventHeader
		}
	}
	return nil
}

func (x *BlockItem) GetRoundHeader() *input.RoundHeader {
	if x != nil {
		if x, ok := x.Item.(*BlockItem_RoundHeader); ok {
			return x.RoundHeader
		}
	}
	return nil
}

func (x *BlockItem) GetEventTransaction() *event.EventTransaction {
	if x != nil {
		if x, ok := x.Item.(*BlockItem_EventTransaction); ok {
			return x.EventTransaction
		}
	}
	return nil
}

func (x *BlockItem) GetTransactionResult() *output.TransactionResult {
	if x != nil {
		if x, ok := x.Item.(*BlockItem_TransactionResult); ok {
			return x.TransactionResult
		}
	}
	return nil
}

func (x *BlockItem) GetTransactionOutput() *output.TransactionOutput {
	if x != nil {
		if x, ok := x.Item.(*BlockItem_TransactionOutput); ok {
			return x.TransactionOutput
		}
	}
	return nil
}

func (x *BlockItem) GetStateChanges() *output.StateChanges {
	if x != nil {
		if x, ok := x.Item.(*BlockItem_StateChanges); ok {
			return x.StateChanges
		}
	}
	return nil
}

func (x *BlockItem) GetFilteredItemHash() *FilteredItemHash {
	if x != nil {
		if x, ok := x.Item.(*BlockItem_FilteredItemHash); ok {
			return x.FilteredItemHash
		}
	}
	return nil
}

func (x *BlockItem) GetBlockProof() *BlockProof {
	if x != nil {
		if x, ok := x.Item.(*BlockItem_BlockProof); ok {
			return x.BlockProof
		}
	}
	return nil
}

func (x *BlockItem) GetRecordFile() *RecordFileItem {
	if x != nil {
		if x, ok := x.Item.(*BlockItem_RecordFile); ok {
			return x.RecordFile
		}
	}
	return nil
}

type isBlockItem_Item interface {
	isBlockItem_Item()
}

type BlockItem_BlockHeader struct {
	// *
	// An header for the block, marking the start of a new block.
	BlockHeader *output.BlockHeader `protobuf:"bytes,1,opt,name=block_header,json=blockHeader,proto3,oneof"`
}

type BlockItem_EventHeader struct {
	// *
	// An header emitted at the start of a new network "event".
	// <p>
	// This item SHALL contain the properties relevant to a single
	// gossip event.
	EventHeader *input.EventHeader `protobuf:"bytes,2,opt,name=event_header,json=eventHeader,proto3,oneof"`
}

type BlockItem_RoundHeader struct {
	// *
	// An header emitted at the start of a new consensus "round".
	// <p>
	// This item SHALL contain the properties relevant to a single
	// consensus round.
	RoundHeader *input.RoundHeader `protobuf:"bytes,3,opt,name=round_header,json=roundHeader,proto3,oneof"`
}

type BlockItem_EventTransaction struct {
	// *
	// A single transaction.
	// <p>
	// This item SHALL contain the serialized bytes of a
	// single transaction.<br/>
	// Each event transaction SHALL be either a `SignedTransaction` or
	// an internal system-generated transaction.<br/>
	// This item MUST NOT contain data for more than one
	// `SignedTransaction` or system-generated transaction.
	EventTransaction *event.EventTransaction `protobuf:"bytes,4,opt,name=event_transaction,json=eventTransaction,proto3,oneof"`
}

type BlockItem_TransactionResult struct {
	// *
	// The result of running a transaction.
	// <p>
	// This item SHALL be present immediately after an
	// `event_transaction` item.<br/>
	// This item MAY be redacted in some circumstances, and SHALL be
	// replaced with a `filtered_item` if removed.
	TransactionResult *output.TransactionResult `protobuf:"bytes,5,opt,name=transaction_result,json=transactionResult,proto3,oneof"`
}

type BlockItem_TransactionOutput struct {
	// *
	// A transaction output.
	// <p>
	// This item MAY not be present if a transaction does not produce
	// an output.<br/>
	// If a transaction does produce an output that is not reflected
	// in state changes, then this item MUST be present after the
	// `transaction_result` for that transaction.
	TransactionOutput *output.TransactionOutput `protobuf:"bytes,6,opt,name=transaction_output,json=transactionOutput,proto3,oneof"`
}

type BlockItem_StateChanges struct {
	// *
	// A set of state changes.
	// <p>
	// All changes to values in network state SHALL be described by
	// stream items of this type.<br/>
	// The source of these state changes SHALL be described by the
	// `reason` enumeration.
	StateChanges *output.StateChanges `protobuf:"bytes,7,opt,name=state_changes,json=stateChanges,proto3,oneof"`
}

type BlockItem_FilteredItemHash struct {
	// *
	// Verification data for an item filtered from the stream.<br/>
	// This is a hash for a merkle tree node where the contents of that
	// part of the merkle tree have been removed from this stream.
	// <p>
	// Items of this type SHALL NOT be present in the full (unfiltered)
	// block stream.<br/>
	// Items of this type SHALL replace any item removed from a partial
	// (filtered) block stream.<br/>
	// Presence of `filtered_item` entries SHALL NOT prevent verification
	// of a block, but MAY preclude verification or reconstruction of
	// consensus state.<br/>
	FilteredItemHash *FilteredItemHash `protobuf:"bytes,8,opt,name=filtered_item_hash,json=filteredItemHash,proto3,oneof"`
}

type BlockItem_BlockProof struct {
	// *
	// A signed block proof.<br/>
	// The signed merkle proof for this block. This will validate
	// a "virtual" merkle tree containing the previous block "virtual"
	// root, an "input" subtree, an "output" subtree, and
	// a "state changes" subtree.
	// <p>
	// This item is not part of the block stream hash chain/tree, and
	// MUST follow after the end of a block.
	BlockProof *BlockProof `protobuf:"bytes,9,opt,name=block_proof,json=blockProof,proto3,oneof"`
}

type BlockItem_RecordFile struct {
	// *
	// A record file and associated data.
	// <p>
	// This MUST contain a single Record file, associated Sidecar files,
	// and data from related Signature files.
	// If this item is present, special treatment is
	// REQUIRED for this block.
	// <ul>
	//
	//	<li>The block SHALL NOT have a `BlockHeader`.</li>
	//	<li>The block SHALL NOT have a `BlockProof`.</li>
	//	<li>The block SHALL contain _exactly one_ `RecordFileItem`.</li>
	//	<li>The block SHALL NOT contain any item other than a
	//	    `RecordFileItem`.</li>
	//	<li>The content of the `RecordFileItem` MUST be validated using
	//	    the signature data and content provided within according to
	//	    the process used for Record Files prior to the creation
	//	    of Block Stream.</li>
	//
	// </ul>
	RecordFile *RecordFileItem `protobuf:"bytes,10,opt,name=record_file,json=recordFile,proto3,oneof"`
}

func (*BlockItem_BlockHeader) isBlockItem_Item() {}

func (*BlockItem_EventHeader) isBlockItem_Item() {}

func (*BlockItem_RoundHeader) isBlockItem_Item() {}

func (*BlockItem_EventTransaction) isBlockItem_Item() {}

func (*BlockItem_TransactionResult) isBlockItem_Item() {}

func (*BlockItem_TransactionOutput) isBlockItem_Item() {}

func (*BlockItem_StateChanges) isBlockItem_Item() {}

func (*BlockItem_FilteredItemHash) isBlockItem_Item() {}

func (*BlockItem_BlockProof) isBlockItem_Item() {}

func (*BlockItem_RecordFile) isBlockItem_Item() {}

// *
// Verification data for an item filtered from the stream.
//
// Items of this type SHALL NOT be present in the full (unfiltered) block
// stream.<br/>
// Items of this type SHALL replace any item removed from a partial (filtered)
// block stream.<br/>
// Presence of `filtered_item` entries SHALL NOT prevent verification
// of a block, but MAY preclude verification or reconstruction
// of consensus state.<br/>
type FilteredItemHash struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// A hash of an item filtered from the stream.
	// <p>
	// The hash algorithm used MUST match the hash algorithm specified in
	// the block header for the containing block.<br/>
	// This field is REQUIRED.
	ItemHash []byte `protobuf:"bytes,1,opt,name=item_hash,json=itemHash,proto3" json:"item_hash,omitempty"`
	// *
	// A record of the merkle path to the item that was filtered
	// from the stream.<br/>
	// This path begins at the root of the block proof merkle tree.
	// <p>
	// This REQUIRED field SHALL describe the full path in the virtual
	// merkle tree constructed for the block proof that contained the
	// item filtered from the stream.
	FilteredPath  uint64 `protobuf:"varint,3,opt,name=filtered_path,json=filteredPath,proto3" json:"filtered_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FilteredItemHash) Reset() {
	*x = FilteredItemHash{}
	mi := &file_stream_block_item_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FilteredItemHash) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FilteredItemHash) ProtoMessage() {}

func (x *FilteredItemHash) ProtoReflect() protoreflect.Message {
	mi := &file_stream_block_item_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FilteredItemHash.ProtoReflect.Descriptor instead.
func (*FilteredItemHash) Descriptor() ([]byte, []int) {
	return file_stream_block_item_proto_rawDescGZIP(), []int{1}
}

func (x *FilteredItemHash) GetItemHash() []byte {
	if x != nil {
		return x.ItemHash
	}
	return nil
}

func (x *FilteredItemHash) GetFilteredPath() uint64 {
	if x != nil {
		return x.FilteredPath
	}
	return 0
}

var File_stream_block_item_proto protoreflect.FileDescriptor

const file_stream_block_item_proto_rawDesc = "" +
	"\n" +
	"\x17stream/block_item.proto\x12\x1ccom.hedera.hapi.block.stream\x1a\x1devent/event_transaction.proto\x1a\x18stream/block_proof.proto\x1a\x1dstream/record_file_item.proto\x1a!stream/input/event_metadata.proto\x1a\x1fstream/input/round_header.proto\x1a stream/output/block_header.proto\x1a!stream/output/state_changes.proto\x1a&stream/output/transaction_output.proto\x1a&stream/output/transaction_result.proto\"\xa1\a\n" +
	"\tBlockItem\x12U\n" +
	"\fblock_header\x18\x01 \x01(\v20.com.hedera.hapi.block.stream.output.BlockHeaderH\x00R\vblockHeader\x12T\n" +
	"\fevent_header\x18\x02 \x01(\v2/.com.hedera.hapi.block.stream.input.EventHeaderH\x00R\veventHeader\x12T\n" +
	"\fround_header\x18\x03 \x01(\v2/.com.hedera.hapi.block.stream.input.RoundHeaderH\x00R\vroundHeader\x12_\n" +
	"\x11event_transaction\x18\x04 \x01(\v20.com.hedera.hapi.platform.event.EventTransactionH\x00R\x10eventTransaction\x12g\n" +
	"\x12transaction_result\x18\x05 \x01(\v26.com.hedera.hapi.block.stream.output.TransactionResultH\x00R\x11transactionResult\x12g\n" +
	"\x12transaction_output\x18\x06 \x01(\v26.com.hedera.hapi.block.stream.output.TransactionOutputH\x00R\x11transactionOutput\x12X\n" +
	"\rstate_changes\x18\a \x01(\v21.com.hedera.hapi.block.stream.output.StateChangesH\x00R\fstateChanges\x12^\n" +
	"\x12filtered_item_hash\x18\b \x01(\v2..com.hedera.hapi.block.stream.FilteredItemHashH\x00R\x10filteredItemHash\x12K\n" +
	"\vblock_proof\x18\t \x01(\v2(.com.hedera.hapi.block.stream.BlockProofH\x00R\n" +
	"blockProof\x12O\n" +
	"\vrecord_file\x18\n" +
	" \x01(\v2,.com.hedera.hapi.block.stream.RecordFileItemH\x00R\n" +
	"recordFileB\x06\n" +
	"\x04item\"T\n" +
	"\x10FilteredItemHash\x12\x1b\n" +
	"\titem_hash\x18\x01 \x01(\fR\bitemHash\x12#\n" +
	"\rfiltered_path\x18\x03 \x01(\x04R\ffilteredPathB_\n" +
	"#com.hedera.hapi.block.stream.protocP\x01Z6github.com/cordialsys/hedera-protobufs-go/block/streamb\x06proto3"

var (
	file_stream_block_item_proto_rawDescOnce sync.Once
	file_stream_block_item_proto_rawDescData []byte
)

func file_stream_block_item_proto_rawDescGZIP() []byte {
	file_stream_block_item_proto_rawDescOnce.Do(func() {
		file_stream_block_item_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_stream_block_item_proto_rawDesc), len(file_stream_block_item_proto_rawDesc)))
	})
	return file_stream_block_item_proto_rawDescData
}

var file_stream_block_item_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_stream_block_item_proto_goTypes = []any{
	(*BlockItem)(nil),                // 0: com.hedera.hapi.block.stream.BlockItem
	(*FilteredItemHash)(nil),         // 1: com.hedera.hapi.block.stream.FilteredItemHash
	(*output.BlockHeader)(nil),       // 2: com.hedera.hapi.block.stream.output.BlockHeader
	(*input.EventHeader)(nil),        // 3: com.hedera.hapi.block.stream.input.EventHeader
	(*input.RoundHeader)(nil),        // 4: com.hedera.hapi.block.stream.input.RoundHeader
	(*event.EventTransaction)(nil),   // 5: com.hedera.hapi.platform.event.EventTransaction
	(*output.TransactionResult)(nil), // 6: com.hedera.hapi.block.stream.output.TransactionResult
	(*output.TransactionOutput)(nil), // 7: com.hedera.hapi.block.stream.output.TransactionOutput
	(*output.StateChanges)(nil),      // 8: com.hedera.hapi.block.stream.output.StateChanges
	(*BlockProof)(nil),               // 9: com.hedera.hapi.block.stream.BlockProof
	(*RecordFileItem)(nil),           // 10: com.hedera.hapi.block.stream.RecordFileItem
}
var file_stream_block_item_proto_depIdxs = []int32{
	2,  // 0: com.hedera.hapi.block.stream.BlockItem.block_header:type_name -> com.hedera.hapi.block.stream.output.BlockHeader
	3,  // 1: com.hedera.hapi.block.stream.BlockItem.event_header:type_name -> com.hedera.hapi.block.stream.input.EventHeader
	4,  // 2: com.hedera.hapi.block.stream.BlockItem.round_header:type_name -> com.hedera.hapi.block.stream.input.RoundHeader
	5,  // 3: com.hedera.hapi.block.stream.BlockItem.event_transaction:type_name -> com.hedera.hapi.platform.event.EventTransaction
	6,  // 4: com.hedera.hapi.block.stream.BlockItem.transaction_result:type_name -> com.hedera.hapi.block.stream.output.TransactionResult
	7,  // 5: com.hedera.hapi.block.stream.BlockItem.transaction_output:type_name -> com.hedera.hapi.block.stream.output.TransactionOutput
	8,  // 6: com.hedera.hapi.block.stream.BlockItem.state_changes:type_name -> com.hedera.hapi.block.stream.output.StateChanges
	1,  // 7: com.hedera.hapi.block.stream.BlockItem.filtered_item_hash:type_name -> com.hedera.hapi.block.stream.FilteredItemHash
	9,  // 8: com.hedera.hapi.block.stream.BlockItem.block_proof:type_name -> com.hedera.hapi.block.stream.BlockProof
	10, // 9: com.hedera.hapi.block.stream.BlockItem.record_file:type_name -> com.hedera.hapi.block.stream.RecordFileItem
	10, // [10:10] is the sub-list for method output_type
	10, // [10:10] is the sub-list for method input_type
	10, // [10:10] is the sub-list for extension type_name
	10, // [10:10] is the sub-list for extension extendee
	0,  // [0:10] is the sub-list for field type_name
}

func init() { file_stream_block_item_proto_init() }
func file_stream_block_item_proto_init() {
	if File_stream_block_item_proto != nil {
		return
	}
	file_stream_block_proof_proto_init()
	file_stream_record_file_item_proto_init()
	file_stream_block_item_proto_msgTypes[0].OneofWrappers = []any{
		(*BlockItem_BlockHeader)(nil),
		(*BlockItem_EventHeader)(nil),
		(*BlockItem_RoundHeader)(nil),
		(*BlockItem_EventTransaction)(nil),
		(*BlockItem_TransactionResult)(nil),
		(*BlockItem_TransactionOutput)(nil),
		(*BlockItem_StateChanges)(nil),
		(*BlockItem_FilteredItemHash)(nil),
		(*BlockItem_BlockProof)(nil),
		(*BlockItem_RecordFile)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_stream_block_item_proto_rawDesc), len(file_stream_block_item_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   2,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_stream_block_item_proto_goTypes,
		DependencyIndexes: file_stream_block_item_proto_depIdxs,
		MessageInfos:      file_stream_block_item_proto_msgTypes,
	}.Build()
	File_stream_block_item_proto = out.File
	file_stream_block_item_proto_goTypes = nil
	file_stream_block_item_proto_depIdxs = nil
}
