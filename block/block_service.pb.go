//*
// # Block Service
// The Service API exposed by the Block Nodes.
//
// ## Workarounds
// > There are incorrect elements in this file to work around bugs in the
// > PBJ Compiler.
// >> Issues 262, 263, 240, 218, 217, and 216 are related.
// >
// > Issue 263
// >> A number of fields reference child messages, these _should_ specify
// >> the parent message (i.e. `Parent.child field = #;`) but do not do
// >> so due to issue 263.
// >
// > Issue 262
// >> Some fields reference messages defined in other packages that share
// >> a common prefix (e.g. `com.hedera.hapi.block.stream`). These fields
// >> specify the entire package instead of the shorter and clearer suffix
// >> due to issue 262
// >
// > Issue 240
// >> These files currently cause PBJ integration tests to fail if included
// >> due to issue 240.
// >
// > Issue 218
// >> These files have the same value for package and java_package. Ideally
// >> we would not specify `java_package` or the pbj comment in that situation,
// >> but Issue 218 prevents eliding the unnecessary directives.
// >
// > Issue 217
// >> These files may cause PBJ to fail compilation due to comments preceeding
// >> the `syntax` keyword.
// >
// > Issue 216
// >> These files would do well with validation support, but cannot make
// >> use of validation, even as an advisory element, due to Issue 216.
//
// ### Keywords
// The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
// "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
// document are to be interpreted as described in
// [RFC2119](https://www.ietf.org/rfc/rfc2119) and clarified in
// [RFC8174](https://www.ietf.org/rfc/rfc8174).

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v5.29.3
// source: block_service.proto

package block

import (
	stream "github.com/cordialsys/hedera-protobufs-go/block/stream"
	common "github.com/cordialsys/hedera-protobufs-go/common"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// *
// An enumeration indicating the status of this request.
//
// This enumeration describes the reason a block stream
// (sent via `publishBlockStream`) ended.
type PublishStreamResponseCode int32

const (
	// *
	// An "unset value" flag, this value SHALL NOT be used.<br/>
	// This status indicates the server software failed to set a
	// status, and SHALL be considered a software defect.
	PublishStreamResponseCode_STREAM_ITEMS_UNKNOWN PublishStreamResponseCode = 0
	// *
	// The request succeeded.<br/>
	// No errors occurred and the source node orderly ended the stream.
	PublishStreamResponseCode_STREAM_ITEMS_SUCCESS PublishStreamResponseCode = 1
	// *
	// The delay between items was too long.<br/>
	// The source MUST start a new stream before the failed block.
	PublishStreamResponseCode_STREAM_ITEMS_TIMEOUT PublishStreamResponseCode = 2
	// *
	// An item was received out-of-order.<br/>
	// The source MUST start a new stream before the failed block.
	PublishStreamResponseCode_STREAM_ITEMS_OUT_OF_ORDER PublishStreamResponseCode = 3
	// *
	// A block state proof item could not be validated.<br/>
	// The source MUST start a new stream before the failed block.
	PublishStreamResponseCode_STREAM_ITEMS_BAD_STATE_PROOF PublishStreamResponseCode = 4
	// *
	// The block node is "behind" the publisher.<br/>
	// Ths consensus node has sent a block later than this block node
	// can process. The publisher may retry by sending blocks immediately
	// following the `block_number` returned, or may end the stream and
	// try again later.
	// <p>
	// Block nodes that are "behind" SHOULD attempt to "catch up" by requesting
	// blocks from another block node or other source of recent historical
	// block stream data.
	PublishStreamResponseCode_STREAM_ITEMS_BEHIND PublishStreamResponseCode = 5
)

// Enum value maps for PublishStreamResponseCode.
var (
	PublishStreamResponseCode_name = map[int32]string{
		0: "STREAM_ITEMS_UNKNOWN",
		1: "STREAM_ITEMS_SUCCESS",
		2: "STREAM_ITEMS_TIMEOUT",
		3: "STREAM_ITEMS_OUT_OF_ORDER",
		4: "STREAM_ITEMS_BAD_STATE_PROOF",
		5: "STREAM_ITEMS_BEHIND",
	}
	PublishStreamResponseCode_value = map[string]int32{
		"STREAM_ITEMS_UNKNOWN":         0,
		"STREAM_ITEMS_SUCCESS":         1,
		"STREAM_ITEMS_TIMEOUT":         2,
		"STREAM_ITEMS_OUT_OF_ORDER":    3,
		"STREAM_ITEMS_BAD_STATE_PROOF": 4,
		"STREAM_ITEMS_BEHIND":          5,
	}
)

func (x PublishStreamResponseCode) Enum() *PublishStreamResponseCode {
	p := new(PublishStreamResponseCode)
	*p = x
	return p
}

func (x PublishStreamResponseCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PublishStreamResponseCode) Descriptor() protoreflect.EnumDescriptor {
	return file_block_service_proto_enumTypes[0].Descriptor()
}

func (PublishStreamResponseCode) Type() protoreflect.EnumType {
	return &file_block_service_proto_enumTypes[0]
}

func (x PublishStreamResponseCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PublishStreamResponseCode.Descriptor instead.
func (PublishStreamResponseCode) EnumDescriptor() ([]byte, []int) {
	return file_block_service_proto_rawDescGZIP(), []int{0}
}

// *
// An enumeration indicating the status of this request.
type SingleBlockResponseCode int32

const (
	// *
	// An "unset value" flag, this value SHALL NOT be used.<br/>
	// This status indicates the server software failed to set a status,
	// and SHALL be considered a software defect.
	SingleBlockResponseCode_READ_BLOCK_UNKNOWN SingleBlockResponseCode = 0
	// *
	// The requesting client account lacks sufficient HBAR to pay the
	// service fee for this request.<br/>
	// The client MAY retry the request, but MUST increase the client
	// account balance with this block node server before doing so.
	SingleBlockResponseCode_READ_BLOCK_INSUFFICIENT_BALANCE SingleBlockResponseCode = 1
	// *
	// The request succeeded.<br/>
	// The requested block SHALL be returned in the `block` field.
	SingleBlockResponseCode_READ_BLOCK_SUCCESS SingleBlockResponseCode = 2
	// *
	// The requested block was not found.<br/>
	// Something failed and a block that SHOULD be available was
	// not found.<br/>
	// The client MAY retry the request; if this result is repeated the
	// request SHOULD be directed to a different block node server.
	SingleBlockResponseCode_READ_BLOCK_NOT_FOUND SingleBlockResponseCode = 3
	// *
	// The requested block is not available on this block node server.<br/>
	// The client SHOULD send a `serverStatus` request to determine the
	// lowest and highest block numbers available at this block node server.
	SingleBlockResponseCode_READ_BLOCK_NOT_AVAILABLE SingleBlockResponseCode = 4
	// *
	// The request for a verified block cannot be fulfilled.<br/>
	// The client requested a verified block from a block node that does not
	// offer verified blocks.
	// <p>
	// The client MAY retry the request with the `allow_unverified` flag set.
	SingleBlockResponseCode_ALLOW_UNVERIFIED_REQUIRED SingleBlockResponseCode = 5
	// *
	// The request for a verified block cannot be fulfilled.<br/>
	// The client requested a verified block from a block node but the
	// requested block is not yet verified.
	// <p>
	// The client MAY retry the request after a short delay
	// (typically 2 seconds or more).
	SingleBlockResponseCode_VERIFIED_BLOCK_UNAVAILABLE SingleBlockResponseCode = 6
)

// Enum value maps for SingleBlockResponseCode.
var (
	SingleBlockResponseCode_name = map[int32]string{
		0: "READ_BLOCK_UNKNOWN",
		1: "READ_BLOCK_INSUFFICIENT_BALANCE",
		2: "READ_BLOCK_SUCCESS",
		3: "READ_BLOCK_NOT_FOUND",
		4: "READ_BLOCK_NOT_AVAILABLE",
		5: "ALLOW_UNVERIFIED_REQUIRED",
		6: "VERIFIED_BLOCK_UNAVAILABLE",
	}
	SingleBlockResponseCode_value = map[string]int32{
		"READ_BLOCK_UNKNOWN":              0,
		"READ_BLOCK_INSUFFICIENT_BALANCE": 1,
		"READ_BLOCK_SUCCESS":              2,
		"READ_BLOCK_NOT_FOUND":            3,
		"READ_BLOCK_NOT_AVAILABLE":        4,
		"ALLOW_UNVERIFIED_REQUIRED":       5,
		"VERIFIED_BLOCK_UNAVAILABLE":      6,
	}
)

func (x SingleBlockResponseCode) Enum() *SingleBlockResponseCode {
	p := new(SingleBlockResponseCode)
	*p = x
	return p
}

func (x SingleBlockResponseCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SingleBlockResponseCode) Descriptor() protoreflect.EnumDescriptor {
	return file_block_service_proto_enumTypes[1].Descriptor()
}

func (SingleBlockResponseCode) Type() protoreflect.EnumType {
	return &file_block_service_proto_enumTypes[1]
}

func (x SingleBlockResponseCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SingleBlockResponseCode.Descriptor instead.
func (SingleBlockResponseCode) EnumDescriptor() ([]byte, []int) {
	return file_block_service_proto_rawDescGZIP(), []int{1}
}

// *
// An enumeration indicating the status of this request.
//
// This response code SHALL be the last message in the stream of responses.
// This code SHALL represent the final status of the full request.
type SubscribeStreamResponseCode int32

const (
	// *
	// An "unset value" flag, this value SHALL NOT be used.<br/>
	// This status indicates the server software failed to set a status,
	// and SHALL be considered a software defect.
	SubscribeStreamResponseCode_READ_STREAM_UNKNOWN SubscribeStreamResponseCode = 0
	// *
	// The requesting client account lacks sufficient HBAR to pay the
	// service fee for this request.<br/>
	// The client MAY retry the request, but MUST increase the client
	// account balance with this block node server before doing so.
	SubscribeStreamResponseCode_READ_STREAM_INSUFFICIENT_BALANCE SubscribeStreamResponseCode = 1
	// *
	// The request succeeded.
	// <p>
	// The requested block(s) SHALL precede the status response
	// with this value.
	SubscribeStreamResponseCode_READ_STREAM_SUCCESS SubscribeStreamResponseCode = 2
	// *
	// The requested start block number is not valid.<br/>
	// The start block number is after the end block number, less
	// than `0`, or otherwise invalid.<br/>
	// The client MAY retry this request, but MUST change the
	// `start_block_number` field to a valid start block.
	SubscribeStreamResponseCode_READ_STREAM_INVALID_START_BLOCK_NUMBER SubscribeStreamResponseCode = 3
	// *
	// The requested end block number is not valid.<br/>
	// The end block number is greater than the highest current block
	// number, less than `0`, or otherwise invalid.<br/>
	// The client MAY retry this request, but MUST change the
	// `end_block_number` field to a valid end block.
	SubscribeStreamResponseCode_READ_STREAM_INVALID_END_BLOCK_NUMBER SubscribeStreamResponseCode = 4
)

// Enum value maps for SubscribeStreamResponseCode.
var (
	SubscribeStreamResponseCode_name = map[int32]string{
		0: "READ_STREAM_UNKNOWN",
		1: "READ_STREAM_INSUFFICIENT_BALANCE",
		2: "READ_STREAM_SUCCESS",
		3: "READ_STREAM_INVALID_START_BLOCK_NUMBER",
		4: "READ_STREAM_INVALID_END_BLOCK_NUMBER",
	}
	SubscribeStreamResponseCode_value = map[string]int32{
		"READ_STREAM_UNKNOWN":                    0,
		"READ_STREAM_INSUFFICIENT_BALANCE":       1,
		"READ_STREAM_SUCCESS":                    2,
		"READ_STREAM_INVALID_START_BLOCK_NUMBER": 3,
		"READ_STREAM_INVALID_END_BLOCK_NUMBER":   4,
	}
)

func (x SubscribeStreamResponseCode) Enum() *SubscribeStreamResponseCode {
	p := new(SubscribeStreamResponseCode)
	*p = x
	return p
}

func (x SubscribeStreamResponseCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SubscribeStreamResponseCode) Descriptor() protoreflect.EnumDescriptor {
	return file_block_service_proto_enumTypes[2].Descriptor()
}

func (SubscribeStreamResponseCode) Type() protoreflect.EnumType {
	return &file_block_service_proto_enumTypes[2]
}

func (x SubscribeStreamResponseCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SubscribeStreamResponseCode.Descriptor instead.
func (SubscribeStreamResponseCode) EnumDescriptor() ([]byte, []int) {
	return file_block_service_proto_rawDescGZIP(), []int{2}
}

// *
// An enumeration indicating the status of a StateSnapshotResponse request.
type StateSnapshotResponseCode int32

const (
	// *
	// An "unset value" flag, this value SHALL NOT be used.<br/>
	// This status indicates the server software failed to set a status,
	// and SHALL be considered a software defect.
	StateSnapshotResponseCode_STATE_SNAPSHOT_UNKNOWN StateSnapshotResponseCode = 0
	// *
	// The requesting client account lacks sufficient HBAR to pay the
	// service fee for this request.<br/>
	// The client MAY retry the request, but MUST increase the client
	// account balance with this block node server before doing so.
	StateSnapshotResponseCode_STATE_SNAPSHOT_INSUFFICIENT_BALANCE StateSnapshotResponseCode = 1
	// *
	// The request succeeded.<br/>
	// The full snapshot data MAY be read via the endpoint provided in the
	// `snapshot_reference` field for the duration specified.
	StateSnapshotResponseCode_STATE_SNAPSHOT_SUCCESS StateSnapshotResponseCode = 2
)

// Enum value maps for StateSnapshotResponseCode.
var (
	StateSnapshotResponseCode_name = map[int32]string{
		0: "STATE_SNAPSHOT_UNKNOWN",
		1: "STATE_SNAPSHOT_INSUFFICIENT_BALANCE",
		2: "STATE_SNAPSHOT_SUCCESS",
	}
	StateSnapshotResponseCode_value = map[string]int32{
		"STATE_SNAPSHOT_UNKNOWN":              0,
		"STATE_SNAPSHOT_INSUFFICIENT_BALANCE": 1,
		"STATE_SNAPSHOT_SUCCESS":              2,
	}
)

func (x StateSnapshotResponseCode) Enum() *StateSnapshotResponseCode {
	p := new(StateSnapshotResponseCode)
	*p = x
	return p
}

func (x StateSnapshotResponseCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (StateSnapshotResponseCode) Descriptor() protoreflect.EnumDescriptor {
	return file_block_service_proto_enumTypes[3].Descriptor()
}

func (StateSnapshotResponseCode) Type() protoreflect.EnumType {
	return &file_block_service_proto_enumTypes[3]
}

func (x StateSnapshotResponseCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use StateSnapshotResponseCode.Descriptor instead.
func (StateSnapshotResponseCode) EnumDescriptor() ([]byte, []int) {
	return file_block_service_proto_rawDescGZIP(), []int{3}
}

// *
// Publish a stream of blocks.
//
// Each item in the stream MUST contain one `BlockItem`.<br/>
// Each Block MUST begin with a single `BlockHeader` block item.<br/>
// The block node SHALL append each `BlockItem` to an internal structure
// to reconstruct full blocks.<br/>
// The block node MUST verify the block proof for each block before sending a
// response message acknowledging that block.<br/>
// Each Block MUST end with a single `BlockStateProof` block item.<br/>
// The block node MUST verify the Block using the `BlockStateProof` to
// ensure all data was received and processed correctly.<br/>
type PublishStreamRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// A single item written to the block stream.
	BlockItem     *stream.BlockItem `protobuf:"bytes,1,opt,name=block_item,json=blockItem,proto3" json:"block_item,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PublishStreamRequest) Reset() {
	*x = PublishStreamRequest{}
	mi := &file_block_service_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublishStreamRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublishStreamRequest) ProtoMessage() {}

func (x *PublishStreamRequest) ProtoReflect() protoreflect.Message {
	mi := &file_block_service_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublishStreamRequest.ProtoReflect.Descriptor instead.
func (*PublishStreamRequest) Descriptor() ([]byte, []int) {
	return file_block_service_proto_rawDescGZIP(), []int{0}
}

func (x *PublishStreamRequest) GetBlockItem() *stream.BlockItem {
	if x != nil {
		return x.BlockItem
	}
	return nil
}

// *
// A response to writing a block stream.
//
// This message is sent in response to each Block in a block stream sent
// to a block node. The block stream is sent as a stream of messages, and each
// message MAY be acknowledged with a message of this type.<br/>
// Each `BlockItem` MAY be acknowledged with an `Acknowledgement`
// response. Item acknowledgement is an OPTIONAL feature.<br/>
// Each completed block SHALL be acknowledged with an `Acknowledgement`
// response. Block acknowledgement is a REQUIRED feature.<br/>
// A final response SHALL be sent with an `EndOfStream` status result after
// the last block stream item is received, or when the receiving system
// must end the stream for any reason.<br/>
// If a failure is detected (which may include a block or block item that
// fails validation) an `EndOfStream` response SHALL be sent with a
// relevant error status.
type PublishStreamResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Response:
	//
	//	*PublishStreamResponse_Acknowledgement_
	//	*PublishStreamResponse_Status
	Response      isPublishStreamResponse_Response `protobuf_oneof:"response"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PublishStreamResponse) Reset() {
	*x = PublishStreamResponse{}
	mi := &file_block_service_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublishStreamResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublishStreamResponse) ProtoMessage() {}

func (x *PublishStreamResponse) ProtoReflect() protoreflect.Message {
	mi := &file_block_service_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublishStreamResponse.ProtoReflect.Descriptor instead.
func (*PublishStreamResponse) Descriptor() ([]byte, []int) {
	return file_block_service_proto_rawDescGZIP(), []int{1}
}

func (x *PublishStreamResponse) GetResponse() isPublishStreamResponse_Response {
	if x != nil {
		return x.Response
	}
	return nil
}

func (x *PublishStreamResponse) GetAcknowledgement() *PublishStreamResponse_Acknowledgement {
	if x != nil {
		if x, ok := x.Response.(*PublishStreamResponse_Acknowledgement_); ok {
			return x.Acknowledgement
		}
	}
	return nil
}

func (x *PublishStreamResponse) GetStatus() *PublishStreamResponse_EndOfStream {
	if x != nil {
		if x, ok := x.Response.(*PublishStreamResponse_Status); ok {
			return x.Status
		}
	}
	return nil
}

type isPublishStreamResponse_Response interface {
	isPublishStreamResponse_Response()
}

type PublishStreamResponse_Acknowledgement_ struct {
	// *
	// A response sent for each block, and optionally for each item.
	Acknowledgement *PublishStreamResponse_Acknowledgement `protobuf:"bytes,1,opt,name=acknowledgement,proto3,oneof"`
}

type PublishStreamResponse_Status struct {
	// *
	// A response sent when a stream ends.
	Status *PublishStreamResponse_EndOfStream `protobuf:"bytes,2,opt,name=status,proto3,oneof"`
}

func (*PublishStreamResponse_Acknowledgement_) isPublishStreamResponse_Response() {}

func (*PublishStreamResponse_Status) isPublishStreamResponse_Response() {}

// *
// A request to read a single block.
//
// A client system SHALL send this message to request a single block,
// including the block state proof.<br/>
// A client MAY request that the block be sent without verification.
// A compliant Block Node MAY respond to requests that allow unverified
// responses by returning the full requested block before verifying
// the included block proof.<br/>
// A compliant Block Node MAY support _only_ requests that allow unverified
// blocks, but MUST clearly document that limitation, and MUST respond to
// a request that does not allow unverified blocks with the
// `ALLOW_UNVERIFIED_REQUIRED` response code.
type SingleBlockRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// The block number of a block to retrieve.
	// <p>
	// The requested block MUST exist on the block node.<br/>
	// This value MUST NOT be set if `retrieve_latest` is set `true`.<br/>
	// This value MUST be set to a valid block number if `retrieve_latest` is
	// unset or is set `false`.
	BlockNumber uint64 `protobuf:"varint,1,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	// *
	// A flag to indicate that the requested block may be sent without
	// verifying its `BlockProof`.<br/>
	// This might be set by a client that expects to perform its own
	// verification and wishes lower latency or, potentially, lower cost.
	// <p>
	// If this value is set, then the responding Block Node MAY respond with a
	// block that has not completed verification of its `BlockProof`.<br/>
	// If this is _not_ set then the Block Node MUST respond with either a
	// fully verified and validated block, or `VERIFIED_BLOCK_UNAVAILABLE` if
	// the requested block is not yet verified.<br/>
	// The default value is _not set_.
	AllowUnverified bool `protobuf:"varint,2,opt,name=allow_unverified,json=allowUnverified,proto3" json:"allow_unverified,omitempty"`
	// *
	// A flag to request the latest available block.
	// <p>
	// This value MAY be set `true` to request the last block available.<br/>
	// If this value is set to `true` then `block_number` MUST NOT be set and
	// SHALL be ignored.
	RetrieveLatest bool `protobuf:"varint,3,opt,name=retrieve_latest,json=retrieveLatest,proto3" json:"retrieve_latest,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *SingleBlockRequest) Reset() {
	*x = SingleBlockRequest{}
	mi := &file_block_service_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SingleBlockRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SingleBlockRequest) ProtoMessage() {}

func (x *SingleBlockRequest) ProtoReflect() protoreflect.Message {
	mi := &file_block_service_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SingleBlockRequest.ProtoReflect.Descriptor instead.
func (*SingleBlockRequest) Descriptor() ([]byte, []int) {
	return file_block_service_proto_rawDescGZIP(), []int{2}
}

func (x *SingleBlockRequest) GetBlockNumber() uint64 {
	if x != nil {
		return x.BlockNumber
	}
	return 0
}

func (x *SingleBlockRequest) GetAllowUnverified() bool {
	if x != nil {
		return x.AllowUnverified
	}
	return false
}

func (x *SingleBlockRequest) GetRetrieveLatest() bool {
	if x != nil {
		return x.RetrieveLatest
	}
	return false
}

// *
// A response to a `singleBlock` request.
//
// This message SHALL be sent in response to a request, and SHALL contain at
// least a valid `status`.<br/>
// If `status` is `READ_BLOCK_SUCCESS`, the response SHALL contain the
// requested block in the `block` field.
//
// > Note
// >> A block can become quite large. A client MUST be prepared to receive the
// >> full content of the block, perhaps many megabytes of data.
type SingleBlockResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// A response status.
	// <p>
	// The reported status SHALL reflect the success of the request, or
	// a detailed reason the request failed.
	Status SingleBlockResponseCode `protobuf:"varint,1,opt,name=status,proto3,enum=com.hedera.hapi.block.SingleBlockResponseCode" json:"status,omitempty"`
	// *
	// The requested block.
	// <p>
	// This container object SHALL hold the entire sequence of block items
	// for the requested block.<br/>
	// The block items in this message SHALL be in the same order
	// as received.<br/>
	// The items in this message SHALL begin with a `BlockHeader` and end with
	// a `BlockStateProof` applicable to this block.
	Block         *stream.Block `protobuf:"bytes,2,opt,name=block,proto3" json:"block,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SingleBlockResponse) Reset() {
	*x = SingleBlockResponse{}
	mi := &file_block_service_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SingleBlockResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SingleBlockResponse) ProtoMessage() {}

func (x *SingleBlockResponse) ProtoReflect() protoreflect.Message {
	mi := &file_block_service_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SingleBlockResponse.ProtoReflect.Descriptor instead.
func (*SingleBlockResponse) Descriptor() ([]byte, []int) {
	return file_block_service_proto_rawDescGZIP(), []int{3}
}

func (x *SingleBlockResponse) GetStatus() SingleBlockResponseCode {
	if x != nil {
		return x.Status
	}
	return SingleBlockResponseCode_READ_BLOCK_UNKNOWN
}

func (x *SingleBlockResponse) GetBlock() *stream.Block {
	if x != nil {
		return x.Block
	}
	return nil
}

// *
// A request to stream block items from block node to a client.
//
// The block node SHALL respond to this request with a stream of
// `SubscribeStreamResponse` messages.<br/>
// The block node SHALL stream the full contents of the blocks requested.<br/>
// The block items SHALL be streamed in order originally produced within
// a block.<br/>
// The blocks SHALL be streamed in ascending order by `block_number`.<br/>
// The block node SHALL end the stream when the last requested block has
// been sent.<br/>
// The block node SHALL end the stream with a response code status of SUCCESS
// when the stream is complete.<br/>
// The client SHOULD call the `serverStatus` rpc prior to constructing this
// request to determine the available start and end blocks.
type SubscribeStreamRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// A block number to start the stream.
	// <p>
	// This SHALL be the block number of the first block returned.<br/>
	// This field MUST be less than or equal to the latest available
	// block number.
	StartBlockNumber uint64 `protobuf:"varint,1,opt,name=start_block_number,json=startBlockNumber,proto3" json:"start_block_number,omitempty"`
	// *
	// A block number to end the stream.<br/>
	// This is optional, and if not set (0), the stream will be "infinite".
	// <p>
	// This field MAY be zero (`0`) to indicate the stream SHOULD continue
	// indefinitely, streaming new blocks as each becomes available.<br/>
	// If this value is greater than zero (`0`)
	// <ul>
	//
	//	<li>This value SHALL be the number of the last block returned.</li>
	//	<li>This field MUST NOT be less than `start_block_number`.</li>
	//	<li>This SHOULD be a block number that is immediately available
	//	    from the block node.</li>
	//	<li>A block node SHALL continue to stream blocks until the last
	//	    requested block is transmitted.</li>
	//	<li>A block node implementation MAY reject a request for a block
	//	    that is not yet available.</li>
	//	<li>A block node implementation MAY accept future block numbers.</li>
	//	<li>Block node implementations MAY charge increased fees for such
	//	    "future" streams.</li>
	//
	// </ul>
	EndBlockNumber uint64 `protobuf:"varint,2,opt,name=end_block_number,json=endBlockNumber,proto3" json:"end_block_number,omitempty"`
	// *
	// A flag to indicate that the requested block(s) may be sent before
	// verifying each block's `BlockProof`.<br/>
	// This might be set by a client that expects to perform its own
	// verification and wishes lower latency or, potentially, lower cost.
	// <p>
	// If this value is set, then the responding Block Node MAY respond with
	// blocks that have not (yet) completed block proof verification.<br/>
	// If this is _not set_ then the Block Node MUST respond with only
	// fully verified and validated block(s).<br/>
	// If this is _set_, then a Block Node MAY stream items from
	// blocks that have not yet been verified or do not yet have
	// a block proof available.<br/>
	// The default value is _not set_.
	AllowUnverified bool `protobuf:"varint,3,opt,name=allow_unverified,json=allowUnverified,proto3" json:"allow_unverified,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *SubscribeStreamRequest) Reset() {
	*x = SubscribeStreamRequest{}
	mi := &file_block_service_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubscribeStreamRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscribeStreamRequest) ProtoMessage() {}

func (x *SubscribeStreamRequest) ProtoReflect() protoreflect.Message {
	mi := &file_block_service_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscribeStreamRequest.ProtoReflect.Descriptor instead.
func (*SubscribeStreamRequest) Descriptor() ([]byte, []int) {
	return file_block_service_proto_rawDescGZIP(), []int{4}
}

func (x *SubscribeStreamRequest) GetStartBlockNumber() uint64 {
	if x != nil {
		return x.StartBlockNumber
	}
	return 0
}

func (x *SubscribeStreamRequest) GetEndBlockNumber() uint64 {
	if x != nil {
		return x.EndBlockNumber
	}
	return 0
}

func (x *SubscribeStreamRequest) GetAllowUnverified() bool {
	if x != nil {
		return x.AllowUnverified
	}
	return false
}

// *
// One item in a stream of `subscribeBlockStream` responses.
//
// The block node SHALL respond to a `subscribeBlockStream` request with a
// stream of `SubscribeStreamResponse` messages.<br/>
// The block node SHALL stream the full contents of the blocks requested.<br/>
// The block items SHALL be streamed in order originally produced within
// a block.<br/>
// The blocks SHALL be streamed in ascending order by `block_number`.<br/>
// The block node SHALL end the stream when the last requested block has
// been sent.<br/>
// The block node SHALL end the stream with a response code status of SUCCESS
// when the stream is complete.<br/>
// The block node SHALL end the stream with a response code status of
// `READ_STREAM_INVALID_START_BLOCK_NUMBER` if the start block number is
// greater than the end block number.<br/>
// The block node SHALL end the stream with a response code status of
// `READ_STREAM_INSUFFICIENT_BALANCE` if insufficient balance remains to
// complete the requested stream.
// The block node SHALL make every reasonable effort to fulfill as much of the
// request as available balance supports, in the event balance is not
// sufficient to complete the request.
type SubscribeStreamResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Response:
	//
	//	*SubscribeStreamResponse_Status
	//	*SubscribeStreamResponse_BlockItem
	Response      isSubscribeStreamResponse_Response `protobuf_oneof:"response"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubscribeStreamResponse) Reset() {
	*x = SubscribeStreamResponse{}
	mi := &file_block_service_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubscribeStreamResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscribeStreamResponse) ProtoMessage() {}

func (x *SubscribeStreamResponse) ProtoReflect() protoreflect.Message {
	mi := &file_block_service_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscribeStreamResponse.ProtoReflect.Descriptor instead.
func (*SubscribeStreamResponse) Descriptor() ([]byte, []int) {
	return file_block_service_proto_rawDescGZIP(), []int{5}
}

func (x *SubscribeStreamResponse) GetResponse() isSubscribeStreamResponse_Response {
	if x != nil {
		return x.Response
	}
	return nil
}

func (x *SubscribeStreamResponse) GetStatus() SubscribeStreamResponseCode {
	if x != nil {
		if x, ok := x.Response.(*SubscribeStreamResponse_Status); ok {
			return x.Status
		}
	}
	return SubscribeStreamResponseCode_READ_STREAM_UNKNOWN
}

func (x *SubscribeStreamResponse) GetBlockItem() *stream.BlockItem {
	if x != nil {
		if x, ok := x.Response.(*SubscribeStreamResponse_BlockItem); ok {
			return x.BlockItem
		}
	}
	return nil
}

type isSubscribeStreamResponse_Response interface {
	isSubscribeStreamResponse_Response()
}

type SubscribeStreamResponse_Status struct {
	// *
	// A final response item describing the terminal status of this stream.
	// <p>
	// The block node server SHALL end the stream following this message.
	Status SubscribeStreamResponseCode `protobuf:"varint,1,opt,name=status,proto3,enum=com.hedera.hapi.block.SubscribeStreamResponseCode,oneof"`
}

type SubscribeStreamResponse_BlockItem struct {
	// *
	// A stream response item containing a single `BlockItem`.
	// <p>
	// The full response SHALL consist of many `block_item` messages
	// followed by a single `status` message.
	BlockItem *stream.BlockItem `protobuf:"bytes,2,opt,name=block_item,json=blockItem,proto3,oneof"`
}

func (*SubscribeStreamResponse_Status) isSubscribeStreamResponse_Response() {}

func (*SubscribeStreamResponse_BlockItem) isSubscribeStreamResponse_Response() {}

// *
// A request to read a state snapshot.
//
// A state snapshot is a full copy of the network state at the completion of a
// particular block.
//
// This request MUST contain a block number that has already reached this block
// node and completed verification, or request the "latest" snapshot.<br/>
// This request MAY specify the "latest" snapshot, and the block node SHALL
// respond with a reference to a snapshot containing the most recent contents
// of the network state known to that block node.
type StateSnapshotRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// A block number.
	// <p>
	// This SHALL be the last block number present in the snapshot
	// returned.<br/>
	// If `retrieve_latest` is set `true` this field SHOULD NOT be set
	// and SHALL be ignored.<br/>
	// A block node implementation MAY reject any request with a non-default
	// value for this field, but MUST clearly document that behavior.
	LastBlockNumber uint64 `protobuf:"varint,2,opt,name=last_block_number,json=lastBlockNumber,proto3" json:"last_block_number,omitempty"`
	// *
	// A boolean to request the latest available snapshot.
	// <p>
	// This value MAY be set `true` to request the most recent state snapshot
	// available.<br/>
	// If this value is set to `true` then `last_block_number` SHOULD NOT be
	// set and SHALL be ignored.<br/>
	// A block node implementation MAY reject any request with that does _not_
	// set this field `true`, but MUST clearly document that behavior.
	RetrieveLatest bool `protobuf:"varint,3,opt,name=retrieve_latest,json=retrieveLatest,proto3" json:"retrieve_latest,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *StateSnapshotRequest) Reset() {
	*x = StateSnapshotRequest{}
	mi := &file_block_service_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StateSnapshotRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StateSnapshotRequest) ProtoMessage() {}

func (x *StateSnapshotRequest) ProtoReflect() protoreflect.Message {
	mi := &file_block_service_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StateSnapshotRequest.ProtoReflect.Descriptor instead.
func (*StateSnapshotRequest) Descriptor() ([]byte, []int) {
	return file_block_service_proto_rawDescGZIP(), []int{6}
}

func (x *StateSnapshotRequest) GetLastBlockNumber() uint64 {
	if x != nil {
		return x.LastBlockNumber
	}
	return 0
}

func (x *StateSnapshotRequest) GetRetrieveLatest() bool {
	if x != nil {
		return x.RetrieveLatest
	}
	return false
}

// *
// A response to a request for a state snapshot.
//
// This message SHALL deliver a _reference_ to the requested snapshot
// data if successful.<br/>
// This message SHALL deliver a code indicating the reason for failure
// if unsuccessful.
type StateSnapshotResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// A status response.
	// <p>
	// This code SHALL indicate a successful call, or the detailed
	// reason for failure.
	Status StateSnapshotResponseCode `protobuf:"varint,1,opt,name=status,proto3,enum=com.hedera.hapi.block.StateSnapshotResponseCode" json:"status,omitempty"`
	// *
	// A block number.
	// <p>
	// This SHALL be the number of the last block included in this
	// state snapshot.
	LastBlockNumber uint64 `protobuf:"varint,2,opt,name=last_block_number,json=lastBlockNumber,proto3" json:"last_block_number,omitempty"`
	// *
	// A reference to where the requested state snapshot may be obtained.
	// <p>
	// <blockquote>REVIEW NOTE<blockquote>
	// This is TEMPORARY.  We have not yet designed how state snapshots may
	// be sent. One idea is to use `Any` and let implementations decide;
	// another is to use a time limited URL (with the same login as the block
	// node server); another is to use a customer-pays cloud storage bucket.
	// </blockquote></blockquote>
	SnapshotReference string `protobuf:"bytes,3,opt,name=snapshot_reference,json=snapshotReference,proto3" json:"snapshot_reference,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *StateSnapshotResponse) Reset() {
	*x = StateSnapshotResponse{}
	mi := &file_block_service_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StateSnapshotResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StateSnapshotResponse) ProtoMessage() {}

func (x *StateSnapshotResponse) ProtoReflect() protoreflect.Message {
	mi := &file_block_service_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StateSnapshotResponse.ProtoReflect.Descriptor instead.
func (*StateSnapshotResponse) Descriptor() ([]byte, []int) {
	return file_block_service_proto_rawDescGZIP(), []int{7}
}

func (x *StateSnapshotResponse) GetStatus() StateSnapshotResponseCode {
	if x != nil {
		return x.Status
	}
	return StateSnapshotResponseCode_STATE_SNAPSHOT_UNKNOWN
}

func (x *StateSnapshotResponse) GetLastBlockNumber() uint64 {
	if x != nil {
		return x.LastBlockNumber
	}
	return 0
}

func (x *StateSnapshotResponse) GetSnapshotReference() string {
	if x != nil {
		return x.SnapshotReference
	}
	return ""
}

// *
// A request for the status of a block node server.
type ServerStatusRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ServerStatusRequest) Reset() {
	*x = ServerStatusRequest{}
	mi := &file_block_service_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerStatusRequest) ProtoMessage() {}

func (x *ServerStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_block_service_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServerStatusRequest.ProtoReflect.Descriptor instead.
func (*ServerStatusRequest) Descriptor() ([]byte, []int) {
	return file_block_service_proto_rawDescGZIP(), []int{8}
}

// *
// A response to a server status request.
//
// This message SHALL provide a client with information needed to successfully
// query this block node server for a block, stream of blocks, or
// state snapshot.<br/>
// A request for blocks between `first_available_block` and
// `last_available_block`, inclusive, SHOULD succeed. Any request for blocks
// outside that range SHOULD fail.
type ServerStatusResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// The lowest numbered block available on this block node server.
	// <p>
	// Any request for a block with lower number than this value SHALL fail
	// with a status value indicating and invalid start block number.
	FirstAvailableBlock uint64 `protobuf:"varint,1,opt,name=first_available_block,json=firstAvailableBlock,proto3" json:"first_available_block,omitempty"`
	// *
	// The greatest block number available from this block node server.
	// <p>
	// Any request for a block with a block number higher than this
	// value MAY fail.
	LastAvailableBlock uint64 `protobuf:"varint,2,opt,name=last_available_block,json=lastAvailableBlock,proto3" json:"last_available_block,omitempty"`
	// *
	// A flag indicating this block node only offers the latest state snapshot.
	// <p>
	// If this value is `true` the client MUST set `retrieve_latest` `true`
	// in any `StateSnapshotRequest` sent to this block node.
	OnlyLatestState bool `protobuf:"varint,3,opt,name=only_latest_state,json=onlyLatestState,proto3" json:"only_latest_state,omitempty"`
	// *
	// Version information.<br/>
	// Versions for the block network address book, block stream protocol
	// buffer schema, and block node software.
	VersionInformation *BlockNodeVersions `protobuf:"bytes,4,opt,name=version_information,json=versionInformation,proto3" json:"version_information,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *ServerStatusResponse) Reset() {
	*x = ServerStatusResponse{}
	mi := &file_block_service_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerStatusResponse) ProtoMessage() {}

func (x *ServerStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_block_service_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServerStatusResponse.ProtoReflect.Descriptor instead.
func (*ServerStatusResponse) Descriptor() ([]byte, []int) {
	return file_block_service_proto_rawDescGZIP(), []int{9}
}

func (x *ServerStatusResponse) GetFirstAvailableBlock() uint64 {
	if x != nil {
		return x.FirstAvailableBlock
	}
	return 0
}

func (x *ServerStatusResponse) GetLastAvailableBlock() uint64 {
	if x != nil {
		return x.LastAvailableBlock
	}
	return 0
}

func (x *ServerStatusResponse) GetOnlyLatestState() bool {
	if x != nil {
		return x.OnlyLatestState
	}
	return false
}

func (x *ServerStatusResponse) GetVersionInformation() *BlockNodeVersions {
	if x != nil {
		return x.VersionInformation
	}
	return nil
}

// *
// Version information for a block node.
//
// The `stream_proto_version` SHOULD be an officially released Block Stream
// version.
// The `address_book_version` SHALL be defined by networks of block nodes.
// The `software_version` SHALL be defined by the implementation of the
// Block Node specification.
type BlockNodeVersions struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// A version of the Block Node network address book.<br/>
	// The address book version describes what version of address book
	// this block node holds for discovering and identifying other block nodes.
	// <p>
	// This version SHALL be specific to each "network" of interconnected
	// Block Nodes.
	AddressBookVersion *common.SemanticVersion `protobuf:"bytes,1,opt,name=address_book_version,json=addressBookVersion,proto3" json:"address_book_version,omitempty"`
	// *
	// A version of the Block Stream specification.<br/>
	// This is the Stream version currently supported by this Block Node.
	// <p>
	// Implementations SHOULD make reasonable effort to ensure the latest
	// released Block Stream version is supported.<br/>
	// This version MUST be an officially released Block Stream version if
	// the responding block node is not private.
	StreamProtoVersion *common.SemanticVersion `protobuf:"bytes,2,opt,name=stream_proto_version,json=streamProtoVersion,proto3" json:"stream_proto_version,omitempty"`
	// *
	// A version of the block node software.<br/>
	// This is the software version that this block node is currently
	// running.
	// <p>
	// This value is implementation-defined.
	SoftwareVersion *common.SemanticVersion `protobuf:"bytes,3,opt,name=software_version,json=softwareVersion,proto3" json:"software_version,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *BlockNodeVersions) Reset() {
	*x = BlockNodeVersions{}
	mi := &file_block_service_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BlockNodeVersions) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BlockNodeVersions) ProtoMessage() {}

func (x *BlockNodeVersions) ProtoReflect() protoreflect.Message {
	mi := &file_block_service_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BlockNodeVersions.ProtoReflect.Descriptor instead.
func (*BlockNodeVersions) Descriptor() ([]byte, []int) {
	return file_block_service_proto_rawDescGZIP(), []int{10}
}

func (x *BlockNodeVersions) GetAddressBookVersion() *common.SemanticVersion {
	if x != nil {
		return x.AddressBookVersion
	}
	return nil
}

func (x *BlockNodeVersions) GetStreamProtoVersion() *common.SemanticVersion {
	if x != nil {
		return x.StreamProtoVersion
	}
	return nil
}

func (x *BlockNodeVersions) GetSoftwareVersion() *common.SemanticVersion {
	if x != nil {
		return x.SoftwareVersion
	}
	return nil
}

// *
// A response to acknowledge receipt and verification of a single item
// or full block.
type PublishStreamResponse_Acknowledgement struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Acknowledgements:
	//
	//	*PublishStreamResponse_Acknowledgement_BlockAck
	//	*PublishStreamResponse_Acknowledgement_ItemAck
	Acknowledgements isPublishStreamResponse_Acknowledgement_Acknowledgements `protobuf_oneof:"acknowledgements"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *PublishStreamResponse_Acknowledgement) Reset() {
	*x = PublishStreamResponse_Acknowledgement{}
	mi := &file_block_service_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublishStreamResponse_Acknowledgement) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublishStreamResponse_Acknowledgement) ProtoMessage() {}

func (x *PublishStreamResponse_Acknowledgement) ProtoReflect() protoreflect.Message {
	mi := &file_block_service_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublishStreamResponse_Acknowledgement.ProtoReflect.Descriptor instead.
func (*PublishStreamResponse_Acknowledgement) Descriptor() ([]byte, []int) {
	return file_block_service_proto_rawDescGZIP(), []int{1, 0}
}

func (x *PublishStreamResponse_Acknowledgement) GetAcknowledgements() isPublishStreamResponse_Acknowledgement_Acknowledgements {
	if x != nil {
		return x.Acknowledgements
	}
	return nil
}

func (x *PublishStreamResponse_Acknowledgement) GetBlockAck() *PublishStreamResponse_BlockAcknowledgement {
	if x != nil {
		if x, ok := x.Acknowledgements.(*PublishStreamResponse_Acknowledgement_BlockAck); ok {
			return x.BlockAck
		}
	}
	return nil
}

func (x *PublishStreamResponse_Acknowledgement) GetItemAck() *PublishStreamResponse_ItemAcknowledgement {
	if x != nil {
		if x, ok := x.Acknowledgements.(*PublishStreamResponse_Acknowledgement_ItemAck); ok {
			return x.ItemAck
		}
	}
	return nil
}

type isPublishStreamResponse_Acknowledgement_Acknowledgements interface {
	isPublishStreamResponse_Acknowledgement_Acknowledgements()
}

type PublishStreamResponse_Acknowledgement_BlockAck struct {
	// *
	// A response type to acknowledge a full and complete block.
	// <p>
	// All block node implementations SHOULD acknowledge each block.
	BlockAck *PublishStreamResponse_BlockAcknowledgement `protobuf:"bytes,1,opt,name=block_ack,json=blockAck,proto3,oneof"`
}

type PublishStreamResponse_Acknowledgement_ItemAck struct {
	// *
	// A response type to acknowledge a single `BlockItem`.<br/>
	// This is an OPTIONAL message and implementations MAY choose to
	// only acknowledge full blocks.
	ItemAck *PublishStreamResponse_ItemAcknowledgement `protobuf:"bytes,2,opt,name=item_ack,json=itemAck,proto3,oneof"`
}

func (*PublishStreamResponse_Acknowledgement_BlockAck) isPublishStreamResponse_Acknowledgement_Acknowledgements() {
}

func (*PublishStreamResponse_Acknowledgement_ItemAck) isPublishStreamResponse_Acknowledgement_Acknowledgements() {
}

// *
// Acknowledgement for a single `BlockItem`.<br/>
// Most nodes are expected to implement this acknowledgement only for
// debugging and development purposes.
//
// If a node implements single item acknowledgement, the block node SHALL
// send one `ItemAcknowledgement` for each `BlockItem` received
// and verified.
type PublishStreamResponse_ItemAcknowledgement struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// A SHA2-384 hash of the `BlockItem` received.
	// <p>
	// This field is REQUIRED.<br/>
	// A source system MUST verify that this value matches its own internal
	// calculated hash value, and MUST end the stream if the values do not
	// match.
	ItemHash      []byte `protobuf:"bytes,1,opt,name=item_hash,json=itemHash,proto3" json:"item_hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PublishStreamResponse_ItemAcknowledgement) Reset() {
	*x = PublishStreamResponse_ItemAcknowledgement{}
	mi := &file_block_service_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublishStreamResponse_ItemAcknowledgement) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublishStreamResponse_ItemAcknowledgement) ProtoMessage() {}

func (x *PublishStreamResponse_ItemAcknowledgement) ProtoReflect() protoreflect.Message {
	mi := &file_block_service_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublishStreamResponse_ItemAcknowledgement.ProtoReflect.Descriptor instead.
func (*PublishStreamResponse_ItemAcknowledgement) Descriptor() ([]byte, []int) {
	return file_block_service_proto_rawDescGZIP(), []int{1, 1}
}

func (x *PublishStreamResponse_ItemAcknowledgement) GetItemHash() []byte {
	if x != nil {
		return x.ItemHash
	}
	return nil
}

// *
// Acknowledgement of a full block.<br/>
// This message is a necessary part of the block streaming protocol.
//
// This response SHALL be sent after a block state proof item is
// received and verified.<br/>
// The block node SHALL send exactly one `BlockAcknowledgement` for
// each successful block.<br/>
// The `BlockAcknowledgement` response MAY be sent after sending an
// `ItemAcknowledgement` response for the `BlockStateProof` item
// at the end of the block, if item acknowledgement is enabled.
type PublishStreamResponse_BlockAcknowledgement struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// A block number number of the acknowledged block.
	// <p>
	// A source system SHOULD verify that this value matches the block sent.
	BlockNumber uint64 `protobuf:"varint,1,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	// *
	// A hash of the virtual merkle root for the block.
	// <p>
	// This SHALL be the hash calculated by the block node for the
	// root node of the virtual merkle tree that is signed by the source
	// system to validate the block.
	BlockRootHash []byte `protobuf:"bytes,2,opt,name=block_root_hash,json=blockRootHash,proto3" json:"block_root_hash,omitempty"`
	// *
	// A flag indicating that the received block duplicates an
	// existing block.
	// <p>
	// If a source system receives acknowledgement with this flag set
	// true the source system SHOULD end the stream. The `block_number`
	// returned SHALL be the last block known and verified by the receiving
	// system, and the source system MAY resume publishing immediately
	// after that block.
	BlockAlreadyExists bool `protobuf:"varint,3,opt,name=block_already_exists,json=blockAlreadyExists,proto3" json:"block_already_exists,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *PublishStreamResponse_BlockAcknowledgement) Reset() {
	*x = PublishStreamResponse_BlockAcknowledgement{}
	mi := &file_block_service_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublishStreamResponse_BlockAcknowledgement) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublishStreamResponse_BlockAcknowledgement) ProtoMessage() {}

func (x *PublishStreamResponse_BlockAcknowledgement) ProtoReflect() protoreflect.Message {
	mi := &file_block_service_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublishStreamResponse_BlockAcknowledgement.ProtoReflect.Descriptor instead.
func (*PublishStreamResponse_BlockAcknowledgement) Descriptor() ([]byte, []int) {
	return file_block_service_proto_rawDescGZIP(), []int{1, 2}
}

func (x *PublishStreamResponse_BlockAcknowledgement) GetBlockNumber() uint64 {
	if x != nil {
		return x.BlockNumber
	}
	return 0
}

func (x *PublishStreamResponse_BlockAcknowledgement) GetBlockRootHash() []byte {
	if x != nil {
		return x.BlockRootHash
	}
	return nil
}

func (x *PublishStreamResponse_BlockAcknowledgement) GetBlockAlreadyExists() bool {
	if x != nil {
		return x.BlockAlreadyExists
	}
	return false
}

// *
// A message sent to end a stream.
//
// This response message SHALL be sent from a block node to a block
// stream source system when a `publishBlockStream` stream ends.<br/>
// This message SHALL be sent exactly once for each `publishBlockStream`
// call.<br/>
// The source system SHALL cease sending block items upon receiving
// this response, and MAY determine the ending state of the stream from
// the `status` enumeration and the `block_number` returned.<br/>
// A source system SHOULD verify that the `block_number` value matches the
// last block sent, and SHOULD resend one or more blocks if the value
// here does not match the expected value.
type PublishStreamResponse_EndOfStream struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// A response code.
	// <p>
	// This code indicates the reason the stream ended.<br/>
	// This value MUST be set to a non-default value.
	Status PublishStreamResponseCode `protobuf:"varint,1,opt,name=status,proto3,enum=com.hedera.hapi.block.PublishStreamResponseCode" json:"status,omitempty"`
	// *
	// The number of the last completed and _verified_ block.
	// <p>
	// Nodes SHOULD only end a stream after a block state proof to avoid
	// the need to resend items.<br/>
	// If status is a failure code, the source node MUST start a new
	// stream at the beginning of the first block _following_ this number
	// (e.g. if this is 91827362983, then the new stream must start with
	// the _header_ for block 91827362984).
	BlockNumber   uint64 `protobuf:"varint,2,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PublishStreamResponse_EndOfStream) Reset() {
	*x = PublishStreamResponse_EndOfStream{}
	mi := &file_block_service_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublishStreamResponse_EndOfStream) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublishStreamResponse_EndOfStream) ProtoMessage() {}

func (x *PublishStreamResponse_EndOfStream) ProtoReflect() protoreflect.Message {
	mi := &file_block_service_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublishStreamResponse_EndOfStream.ProtoReflect.Descriptor instead.
func (*PublishStreamResponse_EndOfStream) Descriptor() ([]byte, []int) {
	return file_block_service_proto_rawDescGZIP(), []int{1, 3}
}

func (x *PublishStreamResponse_EndOfStream) GetStatus() PublishStreamResponseCode {
	if x != nil {
		return x.Status
	}
	return PublishStreamResponseCode_STREAM_ITEMS_UNKNOWN
}

func (x *PublishStreamResponse_EndOfStream) GetBlockNumber() uint64 {
	if x != nil {
		return x.BlockNumber
	}
	return 0
}

var File_block_service_proto protoreflect.FileDescriptor

const file_block_service_proto_rawDesc = "" +
	"\n" +
	"\x13block_service.proto\x12\x15com.hedera.hapi.block\x1a\x11basic_types.proto\x1a\x12stream/block.proto\x1a\x17stream/block_item.proto\"^\n" +
	"\x14PublishStreamRequest\x12F\n" +
	"\n" +
	"block_item\x18\x01 \x01(\v2'.com.hedera.hapi.block.stream.BlockItemR\tblockItem\"\x90\x06\n" +
	"\x15PublishStreamResponse\x12h\n" +
	"\x0facknowledgement\x18\x01 \x01(\v2<.com.hedera.hapi.block.PublishStreamResponse.AcknowledgementH\x00R\x0facknowledgement\x12R\n" +
	"\x06status\x18\x02 \x01(\v28.com.hedera.hapi.block.PublishStreamResponse.EndOfStreamH\x00R\x06status\x1a\xe6\x01\n" +
	"\x0fAcknowledgement\x12`\n" +
	"\tblock_ack\x18\x01 \x01(\v2A.com.hedera.hapi.block.PublishStreamResponse.BlockAcknowledgementH\x00R\bblockAck\x12]\n" +
	"\bitem_ack\x18\x02 \x01(\v2@.com.hedera.hapi.block.PublishStreamResponse.ItemAcknowledgementH\x00R\aitemAckB\x12\n" +
	"\x10acknowledgements\x1a2\n" +
	"\x13ItemAcknowledgement\x12\x1b\n" +
	"\titem_hash\x18\x01 \x01(\fR\bitemHash\x1a\x93\x01\n" +
	"\x14BlockAcknowledgement\x12!\n" +
	"\fblock_number\x18\x01 \x01(\x04R\vblockNumber\x12&\n" +
	"\x0fblock_root_hash\x18\x02 \x01(\fR\rblockRootHash\x120\n" +
	"\x14block_already_exists\x18\x03 \x01(\bR\x12blockAlreadyExists\x1az\n" +
	"\vEndOfStream\x12H\n" +
	"\x06status\x18\x01 \x01(\x0e20.com.hedera.hapi.block.PublishStreamResponseCodeR\x06status\x12!\n" +
	"\fblock_number\x18\x02 \x01(\x04R\vblockNumberB\n" +
	"\n" +
	"\bresponse\"\x8b\x01\n" +
	"\x12SingleBlockRequest\x12!\n" +
	"\fblock_number\x18\x01 \x01(\x04R\vblockNumber\x12)\n" +
	"\x10allow_unverified\x18\x02 \x01(\bR\x0fallowUnverified\x12'\n" +
	"\x0fretrieve_latest\x18\x03 \x01(\bR\x0eretrieveLatest\"\x98\x01\n" +
	"\x13SingleBlockResponse\x12F\n" +
	"\x06status\x18\x01 \x01(\x0e2..com.hedera.hapi.block.SingleBlockResponseCodeR\x06status\x129\n" +
	"\x05block\x18\x02 \x01(\v2#.com.hedera.hapi.block.stream.BlockR\x05block\"\x9b\x01\n" +
	"\x16SubscribeStreamRequest\x12,\n" +
	"\x12start_block_number\x18\x01 \x01(\x04R\x10startBlockNumber\x12(\n" +
	"\x10end_block_number\x18\x02 \x01(\x04R\x0eendBlockNumber\x12)\n" +
	"\x10allow_unverified\x18\x03 \x01(\bR\x0fallowUnverified\"\xbd\x01\n" +
	"\x17SubscribeStreamResponse\x12L\n" +
	"\x06status\x18\x01 \x01(\x0e22.com.hedera.hapi.block.SubscribeStreamResponseCodeH\x00R\x06status\x12H\n" +
	"\n" +
	"block_item\x18\x02 \x01(\v2'.com.hedera.hapi.block.stream.BlockItemH\x00R\tblockItemB\n" +
	"\n" +
	"\bresponse\"k\n" +
	"\x14StateSnapshotRequest\x12*\n" +
	"\x11last_block_number\x18\x02 \x01(\x04R\x0flastBlockNumber\x12'\n" +
	"\x0fretrieve_latest\x18\x03 \x01(\bR\x0eretrieveLatest\"\xbc\x01\n" +
	"\x15StateSnapshotResponse\x12H\n" +
	"\x06status\x18\x01 \x01(\x0e20.com.hedera.hapi.block.StateSnapshotResponseCodeR\x06status\x12*\n" +
	"\x11last_block_number\x18\x02 \x01(\x04R\x0flastBlockNumber\x12-\n" +
	"\x12snapshot_reference\x18\x03 \x01(\tR\x11snapshotReference\"\x15\n" +
	"\x13ServerStatusRequest\"\x83\x02\n" +
	"\x14ServerStatusResponse\x122\n" +
	"\x15first_available_block\x18\x01 \x01(\x04R\x13firstAvailableBlock\x120\n" +
	"\x14last_available_block\x18\x02 \x01(\x04R\x12lastAvailableBlock\x12*\n" +
	"\x11only_latest_state\x18\x03 \x01(\bR\x0fonlyLatestState\x12Y\n" +
	"\x13version_information\x18\x04 \x01(\v2(.com.hedera.hapi.block.BlockNodeVersionsR\x12versionInformation\"\xea\x01\n" +
	"\x11BlockNodeVersions\x12H\n" +
	"\x14address_book_version\x18\x01 \x01(\v2\x16.proto.SemanticVersionR\x12addressBookVersion\x12H\n" +
	"\x14stream_proto_version\x18\x02 \x01(\v2\x16.proto.SemanticVersionR\x12streamProtoVersion\x12A\n" +
	"\x10software_version\x18\x03 \x01(\v2\x16.proto.SemanticVersionR\x0fsoftwareVersion*\xc3\x01\n" +
	"\x19PublishStreamResponseCode\x12\x18\n" +
	"\x14STREAM_ITEMS_UNKNOWN\x10\x00\x12\x18\n" +
	"\x14STREAM_ITEMS_SUCCESS\x10\x01\x12\x18\n" +
	"\x14STREAM_ITEMS_TIMEOUT\x10\x02\x12\x1d\n" +
	"\x19STREAM_ITEMS_OUT_OF_ORDER\x10\x03\x12 \n" +
	"\x1cSTREAM_ITEMS_BAD_STATE_PROOF\x10\x04\x12\x17\n" +
	"\x13STREAM_ITEMS_BEHIND\x10\x05*\xe5\x01\n" +
	"\x17SingleBlockResponseCode\x12\x16\n" +
	"\x12READ_BLOCK_UNKNOWN\x10\x00\x12#\n" +
	"\x1fREAD_BLOCK_INSUFFICIENT_BALANCE\x10\x01\x12\x16\n" +
	"\x12READ_BLOCK_SUCCESS\x10\x02\x12\x18\n" +
	"\x14READ_BLOCK_NOT_FOUND\x10\x03\x12\x1c\n" +
	"\x18READ_BLOCK_NOT_AVAILABLE\x10\x04\x12\x1d\n" +
	"\x19ALLOW_UNVERIFIED_REQUIRED\x10\x05\x12\x1e\n" +
	"\x1aVERIFIED_BLOCK_UNAVAILABLE\x10\x06*\xcb\x01\n" +
	"\x1bSubscribeStreamResponseCode\x12\x17\n" +
	"\x13READ_STREAM_UNKNOWN\x10\x00\x12$\n" +
	" READ_STREAM_INSUFFICIENT_BALANCE\x10\x01\x12\x17\n" +
	"\x13READ_STREAM_SUCCESS\x10\x02\x12*\n" +
	"&READ_STREAM_INVALID_START_BLOCK_NUMBER\x10\x03\x12(\n" +
	"$READ_STREAM_INVALID_END_BLOCK_NUMBER\x10\x04*|\n" +
	"\x19StateSnapshotResponseCode\x12\x1a\n" +
	"\x16STATE_SNAPSHOT_UNKNOWN\x10\x00\x12'\n" +
	"#STATE_SNAPSHOT_INSUFFICIENT_BALANCE\x10\x01\x12\x1a\n" +
	"\x16STATE_SNAPSHOT_SUCCESS\x10\x022\xbd\x04\n" +
	"\x12BlockStreamService\x12g\n" +
	"\fserverStatus\x12*.com.hedera.hapi.block.ServerStatusRequest\x1a+.com.hedera.hapi.block.ServerStatusResponse\x12d\n" +
	"\vsingleBlock\x12).com.hedera.hapi.block.SingleBlockRequest\x1a*.com.hedera.hapi.block.SingleBlockResponse\x12j\n" +
	"\rstateSnapshot\x12+.com.hedera.hapi.block.StateSnapshotRequest\x1a,.com.hedera.hapi.block.StateSnapshotResponse\x12s\n" +
	"\x12publishBlockStream\x12+.com.hedera.hapi.block.PublishStreamRequest\x1a,.com.hedera.hapi.block.PublishStreamResponse(\x010\x01\x12w\n" +
	"\x14subscribeBlockStream\x12-.com.hedera.hapi.block.SubscribeStreamRequest\x1a..com.hedera.hapi.block.SubscribeStreamResponse0\x01BQ\n" +
	"\x1ccom.hedera.hapi.block.protocP\x01Z/github.com/cordialsys/hedera-protobufs-go/blockb\x06proto3"

var (
	file_block_service_proto_rawDescOnce sync.Once
	file_block_service_proto_rawDescData []byte
)

func file_block_service_proto_rawDescGZIP() []byte {
	file_block_service_proto_rawDescOnce.Do(func() {
		file_block_service_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_block_service_proto_rawDesc), len(file_block_service_proto_rawDesc)))
	})
	return file_block_service_proto_rawDescData
}

var file_block_service_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_block_service_proto_msgTypes = make([]protoimpl.MessageInfo, 15)
var file_block_service_proto_goTypes = []any{
	(PublishStreamResponseCode)(0),                     // 0: com.hedera.hapi.block.PublishStreamResponseCode
	(SingleBlockResponseCode)(0),                       // 1: com.hedera.hapi.block.SingleBlockResponseCode
	(SubscribeStreamResponseCode)(0),                   // 2: com.hedera.hapi.block.SubscribeStreamResponseCode
	(StateSnapshotResponseCode)(0),                     // 3: com.hedera.hapi.block.StateSnapshotResponseCode
	(*PublishStreamRequest)(nil),                       // 4: com.hedera.hapi.block.PublishStreamRequest
	(*PublishStreamResponse)(nil),                      // 5: com.hedera.hapi.block.PublishStreamResponse
	(*SingleBlockRequest)(nil),                         // 6: com.hedera.hapi.block.SingleBlockRequest
	(*SingleBlockResponse)(nil),                        // 7: com.hedera.hapi.block.SingleBlockResponse
	(*SubscribeStreamRequest)(nil),                     // 8: com.hedera.hapi.block.SubscribeStreamRequest
	(*SubscribeStreamResponse)(nil),                    // 9: com.hedera.hapi.block.SubscribeStreamResponse
	(*StateSnapshotRequest)(nil),                       // 10: com.hedera.hapi.block.StateSnapshotRequest
	(*StateSnapshotResponse)(nil),                      // 11: com.hedera.hapi.block.StateSnapshotResponse
	(*ServerStatusRequest)(nil),                        // 12: com.hedera.hapi.block.ServerStatusRequest
	(*ServerStatusResponse)(nil),                       // 13: com.hedera.hapi.block.ServerStatusResponse
	(*BlockNodeVersions)(nil),                          // 14: com.hedera.hapi.block.BlockNodeVersions
	(*PublishStreamResponse_Acknowledgement)(nil),      // 15: com.hedera.hapi.block.PublishStreamResponse.Acknowledgement
	(*PublishStreamResponse_ItemAcknowledgement)(nil),  // 16: com.hedera.hapi.block.PublishStreamResponse.ItemAcknowledgement
	(*PublishStreamResponse_BlockAcknowledgement)(nil), // 17: com.hedera.hapi.block.PublishStreamResponse.BlockAcknowledgement
	(*PublishStreamResponse_EndOfStream)(nil),          // 18: com.hedera.hapi.block.PublishStreamResponse.EndOfStream
	(*stream.BlockItem)(nil),                           // 19: com.hedera.hapi.block.stream.BlockItem
	(*stream.Block)(nil),                               // 20: com.hedera.hapi.block.stream.Block
	(*common.SemanticVersion)(nil),                     // 21: proto.SemanticVersion
}
var file_block_service_proto_depIdxs = []int32{
	19, // 0: com.hedera.hapi.block.PublishStreamRequest.block_item:type_name -> com.hedera.hapi.block.stream.BlockItem
	15, // 1: com.hedera.hapi.block.PublishStreamResponse.acknowledgement:type_name -> com.hedera.hapi.block.PublishStreamResponse.Acknowledgement
	18, // 2: com.hedera.hapi.block.PublishStreamResponse.status:type_name -> com.hedera.hapi.block.PublishStreamResponse.EndOfStream
	1,  // 3: com.hedera.hapi.block.SingleBlockResponse.status:type_name -> com.hedera.hapi.block.SingleBlockResponseCode
	20, // 4: com.hedera.hapi.block.SingleBlockResponse.block:type_name -> com.hedera.hapi.block.stream.Block
	2,  // 5: com.hedera.hapi.block.SubscribeStreamResponse.status:type_name -> com.hedera.hapi.block.SubscribeStreamResponseCode
	19, // 6: com.hedera.hapi.block.SubscribeStreamResponse.block_item:type_name -> com.hedera.hapi.block.stream.BlockItem
	3,  // 7: com.hedera.hapi.block.StateSnapshotResponse.status:type_name -> com.hedera.hapi.block.StateSnapshotResponseCode
	14, // 8: com.hedera.hapi.block.ServerStatusResponse.version_information:type_name -> com.hedera.hapi.block.BlockNodeVersions
	21, // 9: com.hedera.hapi.block.BlockNodeVersions.address_book_version:type_name -> proto.SemanticVersion
	21, // 10: com.hedera.hapi.block.BlockNodeVersions.stream_proto_version:type_name -> proto.SemanticVersion
	21, // 11: com.hedera.hapi.block.BlockNodeVersions.software_version:type_name -> proto.SemanticVersion
	17, // 12: com.hedera.hapi.block.PublishStreamResponse.Acknowledgement.block_ack:type_name -> com.hedera.hapi.block.PublishStreamResponse.BlockAcknowledgement
	16, // 13: com.hedera.hapi.block.PublishStreamResponse.Acknowledgement.item_ack:type_name -> com.hedera.hapi.block.PublishStreamResponse.ItemAcknowledgement
	0,  // 14: com.hedera.hapi.block.PublishStreamResponse.EndOfStream.status:type_name -> com.hedera.hapi.block.PublishStreamResponseCode
	12, // 15: com.hedera.hapi.block.BlockStreamService.serverStatus:input_type -> com.hedera.hapi.block.ServerStatusRequest
	6,  // 16: com.hedera.hapi.block.BlockStreamService.singleBlock:input_type -> com.hedera.hapi.block.SingleBlockRequest
	10, // 17: com.hedera.hapi.block.BlockStreamService.stateSnapshot:input_type -> com.hedera.hapi.block.StateSnapshotRequest
	4,  // 18: com.hedera.hapi.block.BlockStreamService.publishBlockStream:input_type -> com.hedera.hapi.block.PublishStreamRequest
	8,  // 19: com.hedera.hapi.block.BlockStreamService.subscribeBlockStream:input_type -> com.hedera.hapi.block.SubscribeStreamRequest
	13, // 20: com.hedera.hapi.block.BlockStreamService.serverStatus:output_type -> com.hedera.hapi.block.ServerStatusResponse
	7,  // 21: com.hedera.hapi.block.BlockStreamService.singleBlock:output_type -> com.hedera.hapi.block.SingleBlockResponse
	11, // 22: com.hedera.hapi.block.BlockStreamService.stateSnapshot:output_type -> com.hedera.hapi.block.StateSnapshotResponse
	5,  // 23: com.hedera.hapi.block.BlockStreamService.publishBlockStream:output_type -> com.hedera.hapi.block.PublishStreamResponse
	9,  // 24: com.hedera.hapi.block.BlockStreamService.subscribeBlockStream:output_type -> com.hedera.hapi.block.SubscribeStreamResponse
	20, // [20:25] is the sub-list for method output_type
	15, // [15:20] is the sub-list for method input_type
	15, // [15:15] is the sub-list for extension type_name
	15, // [15:15] is the sub-list for extension extendee
	0,  // [0:15] is the sub-list for field type_name
}

func init() { file_block_service_proto_init() }
func file_block_service_proto_init() {
	if File_block_service_proto != nil {
		return
	}
	file_block_service_proto_msgTypes[1].OneofWrappers = []any{
		(*PublishStreamResponse_Acknowledgement_)(nil),
		(*PublishStreamResponse_Status)(nil),
	}
	file_block_service_proto_msgTypes[5].OneofWrappers = []any{
		(*SubscribeStreamResponse_Status)(nil),
		(*SubscribeStreamResponse_BlockItem)(nil),
	}
	file_block_service_proto_msgTypes[11].OneofWrappers = []any{
		(*PublishStreamResponse_Acknowledgement_BlockAck)(nil),
		(*PublishStreamResponse_Acknowledgement_ItemAck)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_block_service_proto_rawDesc), len(file_block_service_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   15,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_block_service_proto_goTypes,
		DependencyIndexes: file_block_service_proto_depIdxs,
		EnumInfos:         file_block_service_proto_enumTypes,
		MessageInfos:      file_block_service_proto_msgTypes,
	}.Build()
	File_block_service_proto = out.File
	file_block_service_proto_goTypes = nil
	file_block_service_proto_depIdxs = nil
}
