// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v5.29.3
// source: token_get_info.proto

package services

import (
	common "github.com/cordialsys/hedera-protobufs-go/common"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// *
// Gets information about Token instance
type TokenGetInfoQuery struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// Standard info sent from client to node, including the signed payment, and what kind of
	// response is requested (cost, state proof, both, or neither)
	Header *QueryHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// *
	// The token for which information is requested. If invalid token is provided, INVALID_TOKEN_ID
	// response is returned.
	Token         *common.TokenID `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TokenGetInfoQuery) Reset() {
	*x = TokenGetInfoQuery{}
	mi := &file_token_get_info_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenGetInfoQuery) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenGetInfoQuery) ProtoMessage() {}

func (x *TokenGetInfoQuery) ProtoReflect() protoreflect.Message {
	mi := &file_token_get_info_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenGetInfoQuery.ProtoReflect.Descriptor instead.
func (*TokenGetInfoQuery) Descriptor() ([]byte, []int) {
	return file_token_get_info_proto_rawDescGZIP(), []int{0}
}

func (x *TokenGetInfoQuery) GetHeader() *QueryHeader {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *TokenGetInfoQuery) GetToken() *common.TokenID {
	if x != nil {
		return x.Token
	}
	return nil
}

// *
// The metadata about a Token instance
type TokenInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// ID of the token instance
	TokenId *common.TokenID `protobuf:"bytes,1,opt,name=tokenId,proto3" json:"tokenId,omitempty"`
	// *
	// The name of the token. It is a string of ASCII only characters
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// *
	// The symbol of the token. It is a UTF-8 capitalized alphabetical string
	Symbol string `protobuf:"bytes,3,opt,name=symbol,proto3" json:"symbol,omitempty"`
	// *
	// The number of decimal places a token is divisible by. Always 0 for tokens of type
	// NON_FUNGIBLE_UNIQUE
	Decimals uint32 `protobuf:"varint,4,opt,name=decimals,proto3" json:"decimals,omitempty"`
	// *
	// For tokens of type FUNGIBLE_COMMON - the total supply of tokens that are currently in
	// circulation. For tokens of type NON_FUNGIBLE_UNIQUE - the number of NFTs created of this
	// token instance
	TotalSupply uint64 `protobuf:"varint,5,opt,name=totalSupply,proto3" json:"totalSupply,omitempty"`
	// *
	// The ID of the account which is set as Treasury
	Treasury *common.AccountID `protobuf:"bytes,6,opt,name=treasury,proto3" json:"treasury,omitempty"`
	// *
	// The key which can perform update/delete operations on the token. If empty, the token can be
	// perceived as immutable (not being able to be updated/deleted)
	AdminKey *common.Key `protobuf:"bytes,7,opt,name=adminKey,proto3" json:"adminKey,omitempty"`
	// *
	// The key which can grant or revoke KYC of an account for the token's transactions. If empty,
	// KYC is not required, and KYC grant or revoke operations are not possible.
	KycKey *common.Key `protobuf:"bytes,8,opt,name=kycKey,proto3" json:"kycKey,omitempty"`
	// *
	// The key which can freeze or unfreeze an account for token transactions. If empty, freezing is
	// not possible
	FreezeKey *common.Key `protobuf:"bytes,9,opt,name=freezeKey,proto3" json:"freezeKey,omitempty"`
	// *
	// The key which can wipe token balance of an account. If empty, wipe is not possible
	WipeKey *common.Key `protobuf:"bytes,10,opt,name=wipeKey,proto3" json:"wipeKey,omitempty"`
	// *
	// The key which can change the supply of a token. The key is used to sign Token Mint/Burn
	// operations
	SupplyKey *common.Key `protobuf:"bytes,11,opt,name=supplyKey,proto3" json:"supplyKey,omitempty"`
	// *
	// The default Freeze status (not applicable, frozen or unfrozen) of Hedera accounts relative to
	// this token. FreezeNotApplicable is returned if Token Freeze Key is empty. Frozen is returned
	// if Token Freeze Key is set and defaultFreeze is set to true. Unfrozen is returned if Token
	// Freeze Key is set and defaultFreeze is set to false
	DefaultFreezeStatus common.TokenFreezeStatus `protobuf:"varint,12,opt,name=defaultFreezeStatus,proto3,enum=proto.TokenFreezeStatus" json:"defaultFreezeStatus,omitempty"`
	// *
	// The default KYC status (KycNotApplicable or Revoked) of Hedera accounts relative to this
	// token. KycNotApplicable is returned if KYC key is not set, otherwise Revoked
	DefaultKycStatus common.TokenKycStatus `protobuf:"varint,13,opt,name=defaultKycStatus,proto3,enum=proto.TokenKycStatus" json:"defaultKycStatus,omitempty"`
	// *
	// Specifies whether the token was deleted or not
	Deleted bool `protobuf:"varint,14,opt,name=deleted,proto3" json:"deleted,omitempty"`
	// *
	// An account which will be automatically charged to renew the token's expiration, at
	// autoRenewPeriod interval
	AutoRenewAccount *common.AccountID `protobuf:"bytes,15,opt,name=autoRenewAccount,proto3" json:"autoRenewAccount,omitempty"`
	// *
	// The interval at which the auto-renew account will be charged to extend the token's expiry
	AutoRenewPeriod *Duration `protobuf:"bytes,16,opt,name=autoRenewPeriod,proto3" json:"autoRenewPeriod,omitempty"`
	// *
	// The epoch second at which the token will expire
	Expiry *common.Timestamp `protobuf:"bytes,17,opt,name=expiry,proto3" json:"expiry,omitempty"`
	// *
	// The memo associated with the token
	Memo string `protobuf:"bytes,18,opt,name=memo,proto3" json:"memo,omitempty"`
	// *
	// The token type
	TokenType common.TokenType `protobuf:"varint,19,opt,name=tokenType,proto3,enum=proto.TokenType" json:"tokenType,omitempty"`
	// *
	// The token supply type
	SupplyType common.TokenSupplyType `protobuf:"varint,20,opt,name=supplyType,proto3,enum=proto.TokenSupplyType" json:"supplyType,omitempty"`
	// *
	// For tokens of type FUNGIBLE_COMMON - The Maximum number of fungible tokens that can be in
	// circulation. For tokens of type NON_FUNGIBLE_UNIQUE - the maximum number of NFTs (serial
	// numbers) that can be in circulation
	MaxSupply int64 `protobuf:"varint,21,opt,name=maxSupply,proto3" json:"maxSupply,omitempty"`
	// *
	// The key which can change the custom fee schedule of the token; if not set, the fee schedule
	// is immutable
	FeeScheduleKey *common.Key `protobuf:"bytes,22,opt,name=fee_schedule_key,json=feeScheduleKey,proto3" json:"fee_schedule_key,omitempty"`
	// *
	// The custom fees to be assessed during a CryptoTransfer that transfers units of this token
	CustomFees []*CustomFee `protobuf:"bytes,23,rep,name=custom_fees,json=customFees,proto3" json:"custom_fees,omitempty"`
	// *
	// The Key which can pause and unpause the Token.
	PauseKey *common.Key `protobuf:"bytes,24,opt,name=pause_key,json=pauseKey,proto3" json:"pause_key,omitempty"`
	// *
	// Specifies whether the token is paused or not. PauseNotApplicable is returned if pauseKey is not set.
	PauseStatus common.TokenPauseStatus `protobuf:"varint,25,opt,name=pause_status,json=pauseStatus,proto3,enum=proto.TokenPauseStatus" json:"pause_status,omitempty"`
	// *
	// The ledger ID the response was returned from; please see <a href="https://github.com/hashgraph/hedera-improvement-proposal/blob/master/HIP/hip-198.md">HIP-198</a> for the network-specific IDs.
	LedgerId []byte `protobuf:"bytes,26,opt,name=ledger_id,json=ledgerId,proto3" json:"ledger_id,omitempty"`
	// *
	// Represents the metadata of the token definition.
	Metadata []byte `protobuf:"bytes,27,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// *
	// The key which can change the metadata of a token
	// (token definition and individual NFTs).
	MetadataKey   *common.Key `protobuf:"bytes,28,opt,name=metadata_key,json=metadataKey,proto3" json:"metadata_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TokenInfo) Reset() {
	*x = TokenInfo{}
	mi := &file_token_get_info_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenInfo) ProtoMessage() {}

func (x *TokenInfo) ProtoReflect() protoreflect.Message {
	mi := &file_token_get_info_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenInfo.ProtoReflect.Descriptor instead.
func (*TokenInfo) Descriptor() ([]byte, []int) {
	return file_token_get_info_proto_rawDescGZIP(), []int{1}
}

func (x *TokenInfo) GetTokenId() *common.TokenID {
	if x != nil {
		return x.TokenId
	}
	return nil
}

func (x *TokenInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *TokenInfo) GetSymbol() string {
	if x != nil {
		return x.Symbol
	}
	return ""
}

func (x *TokenInfo) GetDecimals() uint32 {
	if x != nil {
		return x.Decimals
	}
	return 0
}

func (x *TokenInfo) GetTotalSupply() uint64 {
	if x != nil {
		return x.TotalSupply
	}
	return 0
}

func (x *TokenInfo) GetTreasury() *common.AccountID {
	if x != nil {
		return x.Treasury
	}
	return nil
}

func (x *TokenInfo) GetAdminKey() *common.Key {
	if x != nil {
		return x.AdminKey
	}
	return nil
}

func (x *TokenInfo) GetKycKey() *common.Key {
	if x != nil {
		return x.KycKey
	}
	return nil
}

func (x *TokenInfo) GetFreezeKey() *common.Key {
	if x != nil {
		return x.FreezeKey
	}
	return nil
}

func (x *TokenInfo) GetWipeKey() *common.Key {
	if x != nil {
		return x.WipeKey
	}
	return nil
}

func (x *TokenInfo) GetSupplyKey() *common.Key {
	if x != nil {
		return x.SupplyKey
	}
	return nil
}

func (x *TokenInfo) GetDefaultFreezeStatus() common.TokenFreezeStatus {
	if x != nil {
		return x.DefaultFreezeStatus
	}
	return common.TokenFreezeStatus(0)
}

func (x *TokenInfo) GetDefaultKycStatus() common.TokenKycStatus {
	if x != nil {
		return x.DefaultKycStatus
	}
	return common.TokenKycStatus(0)
}

func (x *TokenInfo) GetDeleted() bool {
	if x != nil {
		return x.Deleted
	}
	return false
}

func (x *TokenInfo) GetAutoRenewAccount() *common.AccountID {
	if x != nil {
		return x.AutoRenewAccount
	}
	return nil
}

func (x *TokenInfo) GetAutoRenewPeriod() *Duration {
	if x != nil {
		return x.AutoRenewPeriod
	}
	return nil
}

func (x *TokenInfo) GetExpiry() *common.Timestamp {
	if x != nil {
		return x.Expiry
	}
	return nil
}

func (x *TokenInfo) GetMemo() string {
	if x != nil {
		return x.Memo
	}
	return ""
}

func (x *TokenInfo) GetTokenType() common.TokenType {
	if x != nil {
		return x.TokenType
	}
	return common.TokenType(0)
}

func (x *TokenInfo) GetSupplyType() common.TokenSupplyType {
	if x != nil {
		return x.SupplyType
	}
	return common.TokenSupplyType(0)
}

func (x *TokenInfo) GetMaxSupply() int64 {
	if x != nil {
		return x.MaxSupply
	}
	return 0
}

func (x *TokenInfo) GetFeeScheduleKey() *common.Key {
	if x != nil {
		return x.FeeScheduleKey
	}
	return nil
}

func (x *TokenInfo) GetCustomFees() []*CustomFee {
	if x != nil {
		return x.CustomFees
	}
	return nil
}

func (x *TokenInfo) GetPauseKey() *common.Key {
	if x != nil {
		return x.PauseKey
	}
	return nil
}

func (x *TokenInfo) GetPauseStatus() common.TokenPauseStatus {
	if x != nil {
		return x.PauseStatus
	}
	return common.TokenPauseStatus(0)
}

func (x *TokenInfo) GetLedgerId() []byte {
	if x != nil {
		return x.LedgerId
	}
	return nil
}

func (x *TokenInfo) GetMetadata() []byte {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *TokenInfo) GetMetadataKey() *common.Key {
	if x != nil {
		return x.MetadataKey
	}
	return nil
}

// *
// Response when the client sends the node TokenGetInfoQuery
type TokenGetInfoResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// Standard response from node to client, including the requested fields: cost, or state proof,
	// or both, or neither
	Header *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// *
	// The information requested about this token instance
	TokenInfo     *TokenInfo `protobuf:"bytes,2,opt,name=tokenInfo,proto3" json:"tokenInfo,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TokenGetInfoResponse) Reset() {
	*x = TokenGetInfoResponse{}
	mi := &file_token_get_info_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TokenGetInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TokenGetInfoResponse) ProtoMessage() {}

func (x *TokenGetInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_token_get_info_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TokenGetInfoResponse.ProtoReflect.Descriptor instead.
func (*TokenGetInfoResponse) Descriptor() ([]byte, []int) {
	return file_token_get_info_proto_rawDescGZIP(), []int{2}
}

func (x *TokenGetInfoResponse) GetHeader() *ResponseHeader {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *TokenGetInfoResponse) GetTokenInfo() *TokenInfo {
	if x != nil {
		return x.TokenInfo
	}
	return nil
}

var File_token_get_info_proto protoreflect.FileDescriptor

const file_token_get_info_proto_rawDesc = "" +
	"\n" +
	"\x14token_get_info.proto\x12\x05proto\x1a\x11basic_types.proto\x1a\x11custom_fees.proto\x1a\x12query_header.proto\x1a\x15response_header.proto\x1a\x0ftimestamp.proto\x1a\x0eduration.proto\"e\n" +
	"\x11TokenGetInfoQuery\x12*\n" +
	"\x06header\x18\x01 \x01(\v2\x12.proto.QueryHeaderR\x06header\x12$\n" +
	"\x05token\x18\x02 \x01(\v2\x0e.proto.TokenIDR\x05token\"\xaf\t\n" +
	"\tTokenInfo\x12(\n" +
	"\atokenId\x18\x01 \x01(\v2\x0e.proto.TokenIDR\atokenId\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x16\n" +
	"\x06symbol\x18\x03 \x01(\tR\x06symbol\x12\x1a\n" +
	"\bdecimals\x18\x04 \x01(\rR\bdecimals\x12 \n" +
	"\vtotalSupply\x18\x05 \x01(\x04R\vtotalSupply\x12,\n" +
	"\btreasury\x18\x06 \x01(\v2\x10.proto.AccountIDR\btreasury\x12&\n" +
	"\badminKey\x18\a \x01(\v2\n" +
	".proto.KeyR\badminKey\x12\"\n" +
	"\x06kycKey\x18\b \x01(\v2\n" +
	".proto.KeyR\x06kycKey\x12(\n" +
	"\tfreezeKey\x18\t \x01(\v2\n" +
	".proto.KeyR\tfreezeKey\x12$\n" +
	"\awipeKey\x18\n" +
	" \x01(\v2\n" +
	".proto.KeyR\awipeKey\x12(\n" +
	"\tsupplyKey\x18\v \x01(\v2\n" +
	".proto.KeyR\tsupplyKey\x12J\n" +
	"\x13defaultFreezeStatus\x18\f \x01(\x0e2\x18.proto.TokenFreezeStatusR\x13defaultFreezeStatus\x12A\n" +
	"\x10defaultKycStatus\x18\r \x01(\x0e2\x15.proto.TokenKycStatusR\x10defaultKycStatus\x12\x18\n" +
	"\adeleted\x18\x0e \x01(\bR\adeleted\x12<\n" +
	"\x10autoRenewAccount\x18\x0f \x01(\v2\x10.proto.AccountIDR\x10autoRenewAccount\x129\n" +
	"\x0fautoRenewPeriod\x18\x10 \x01(\v2\x0f.proto.DurationR\x0fautoRenewPeriod\x12(\n" +
	"\x06expiry\x18\x11 \x01(\v2\x10.proto.TimestampR\x06expiry\x12\x12\n" +
	"\x04memo\x18\x12 \x01(\tR\x04memo\x12.\n" +
	"\ttokenType\x18\x13 \x01(\x0e2\x10.proto.TokenTypeR\ttokenType\x126\n" +
	"\n" +
	"supplyType\x18\x14 \x01(\x0e2\x16.proto.TokenSupplyTypeR\n" +
	"supplyType\x12\x1c\n" +
	"\tmaxSupply\x18\x15 \x01(\x03R\tmaxSupply\x124\n" +
	"\x10fee_schedule_key\x18\x16 \x01(\v2\n" +
	".proto.KeyR\x0efeeScheduleKey\x121\n" +
	"\vcustom_fees\x18\x17 \x03(\v2\x10.proto.CustomFeeR\n" +
	"customFees\x12'\n" +
	"\tpause_key\x18\x18 \x01(\v2\n" +
	".proto.KeyR\bpauseKey\x12:\n" +
	"\fpause_status\x18\x19 \x01(\x0e2\x17.proto.TokenPauseStatusR\vpauseStatus\x12\x1b\n" +
	"\tledger_id\x18\x1a \x01(\fR\bledgerId\x12\x1a\n" +
	"\bmetadata\x18\x1b \x01(\fR\bmetadata\x12-\n" +
	"\fmetadata_key\x18\x1c \x01(\v2\n" +
	".proto.KeyR\vmetadataKey\"u\n" +
	"\x14TokenGetInfoResponse\x12-\n" +
	"\x06header\x18\x01 \x01(\v2\x15.proto.ResponseHeaderR\x06header\x12.\n" +
	"\ttokenInfo\x18\x02 \x01(\v2\x10.proto.TokenInfoR\ttokenInfoBZ\n" +
	"\"com.hederahashgraph.api.proto.javaP\x01Z2github.com/cordialsys/hedera-protobufs-go/servicesb\x06proto3"

var (
	file_token_get_info_proto_rawDescOnce sync.Once
	file_token_get_info_proto_rawDescData []byte
)

func file_token_get_info_proto_rawDescGZIP() []byte {
	file_token_get_info_proto_rawDescOnce.Do(func() {
		file_token_get_info_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_token_get_info_proto_rawDesc), len(file_token_get_info_proto_rawDesc)))
	})
	return file_token_get_info_proto_rawDescData
}

var file_token_get_info_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_token_get_info_proto_goTypes = []any{
	(*TokenGetInfoQuery)(nil),     // 0: proto.TokenGetInfoQuery
	(*TokenInfo)(nil),             // 1: proto.TokenInfo
	(*TokenGetInfoResponse)(nil),  // 2: proto.TokenGetInfoResponse
	(*QueryHeader)(nil),           // 3: proto.QueryHeader
	(*common.TokenID)(nil),        // 4: proto.TokenID
	(*common.AccountID)(nil),      // 5: proto.AccountID
	(*common.Key)(nil),            // 6: proto.Key
	(common.TokenFreezeStatus)(0), // 7: proto.TokenFreezeStatus
	(common.TokenKycStatus)(0),    // 8: proto.TokenKycStatus
	(*Duration)(nil),              // 9: proto.Duration
	(*common.Timestamp)(nil),      // 10: proto.Timestamp
	(common.TokenType)(0),         // 11: proto.TokenType
	(common.TokenSupplyType)(0),   // 12: proto.TokenSupplyType
	(*CustomFee)(nil),             // 13: proto.CustomFee
	(common.TokenPauseStatus)(0),  // 14: proto.TokenPauseStatus
	(*ResponseHeader)(nil),        // 15: proto.ResponseHeader
}
var file_token_get_info_proto_depIdxs = []int32{
	3,  // 0: proto.TokenGetInfoQuery.header:type_name -> proto.QueryHeader
	4,  // 1: proto.TokenGetInfoQuery.token:type_name -> proto.TokenID
	4,  // 2: proto.TokenInfo.tokenId:type_name -> proto.TokenID
	5,  // 3: proto.TokenInfo.treasury:type_name -> proto.AccountID
	6,  // 4: proto.TokenInfo.adminKey:type_name -> proto.Key
	6,  // 5: proto.TokenInfo.kycKey:type_name -> proto.Key
	6,  // 6: proto.TokenInfo.freezeKey:type_name -> proto.Key
	6,  // 7: proto.TokenInfo.wipeKey:type_name -> proto.Key
	6,  // 8: proto.TokenInfo.supplyKey:type_name -> proto.Key
	7,  // 9: proto.TokenInfo.defaultFreezeStatus:type_name -> proto.TokenFreezeStatus
	8,  // 10: proto.TokenInfo.defaultKycStatus:type_name -> proto.TokenKycStatus
	5,  // 11: proto.TokenInfo.autoRenewAccount:type_name -> proto.AccountID
	9,  // 12: proto.TokenInfo.autoRenewPeriod:type_name -> proto.Duration
	10, // 13: proto.TokenInfo.expiry:type_name -> proto.Timestamp
	11, // 14: proto.TokenInfo.tokenType:type_name -> proto.TokenType
	12, // 15: proto.TokenInfo.supplyType:type_name -> proto.TokenSupplyType
	6,  // 16: proto.TokenInfo.fee_schedule_key:type_name -> proto.Key
	13, // 17: proto.TokenInfo.custom_fees:type_name -> proto.CustomFee
	6,  // 18: proto.TokenInfo.pause_key:type_name -> proto.Key
	14, // 19: proto.TokenInfo.pause_status:type_name -> proto.TokenPauseStatus
	6,  // 20: proto.TokenInfo.metadata_key:type_name -> proto.Key
	15, // 21: proto.TokenGetInfoResponse.header:type_name -> proto.ResponseHeader
	1,  // 22: proto.TokenGetInfoResponse.tokenInfo:type_name -> proto.TokenInfo
	23, // [23:23] is the sub-list for method output_type
	23, // [23:23] is the sub-list for method input_type
	23, // [23:23] is the sub-list for extension type_name
	23, // [23:23] is the sub-list for extension extendee
	0,  // [0:23] is the sub-list for field type_name
}

func init() { file_token_get_info_proto_init() }
func file_token_get_info_proto_init() {
	if File_token_get_info_proto != nil {
		return
	}
	file_custom_fees_proto_init()
	file_query_header_proto_init()
	file_response_header_proto_init()
	file_duration_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_token_get_info_proto_rawDesc), len(file_token_get_info_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   3,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_token_get_info_proto_goTypes,
		DependencyIndexes: file_token_get_info_proto_depIdxs,
		MessageInfos:      file_token_get_info_proto_msgTypes,
	}.Build()
	File_token_get_info_proto = out.File
	file_token_get_info_proto_goTypes = nil
	file_token_get_info_proto_depIdxs = nil
}
